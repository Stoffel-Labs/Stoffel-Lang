# Federated Matrix Average using Fixed-Point Shares
#
# This program computes the element-wise AVERAGE of matrix elements across multiple clients
# using fixed-point secret shares. Each client provides 6 elements (2 rows x 3 cols).
#
# This version uses the FederatedLearning.average_client_shares builtin which:
# 1. Gets all client shares from the ClientStore
# 2. Sums them element-wise (each position across all clients)
# 3. Batch reveals all sums in a single efficient network operation
# 4. Divides each sum by the number of clients to get the average
#
# The builtin is much more efficient than manual loops because it:
# - Uses batch reveal instead of individual reveals (fewer network rounds)
# - Performs all operations in optimized Rust code

# Computes element-wise federated average across all clients using builtin
# Returns: an array of per-element averages (as floats, still fixed-point scaled)
def federated_average_2x3() -> list[float]:
  # Matrix size: 2x3 = 6 elements per client
  var matrix_size: int64 = 6

  # Use the FederatedLearning builtin to compute average in one efficient call
  # The "fixed" argument tells it to use SecretFixedPoint shares
  var averages: list[float] = FederatedLearning.average_client_shares(matrix_size, "fixed")

  return averages

# Entry point - returns the array of per-element averages
main main() -> list[float]:
  var averages: list[float] = federated_average_2x3()

  # The averages array contains per-element averages:
  # averages[i] = average of element i across all clients
  # Values are still fixed-point scaled by 2^16
  # To get actual float value: averages[i] / 65536.0

  return averages
