# These examples assume the parser can generate the initial AST nodes
# that the UFCS transform expects.

# Style 1: obj.method(arg1, arg2) -> method(obj, arg1, arg2)
# Assuming 'my_obj' exists and has a 'process' method
var result = my_obj.process(data, config)

# Style 3: obj method arg1 arg2 -> method(obj, arg1, arg2)
# (Requires parser support for command calls)
var result = my_obj process data config

# Style 4: arg1.op(arg2) -> op(arg1, arg2)
# Assuming 'a' and 'b' exist
var sum = a.add(b)
var difference = a.subtract(b)

# Nested calls: a.b(c).d(e) -> d(b(a, c), e)
var final_result = first_obj.step_one(input).step_two(modifier)

# Chained field access before call: obj.field.method(arg) -> method(obj.field, arg)
var field_result = complex_obj.settings.apply(value)

# Note: Actual execution requires function definitions and object types.
# These lines primarily test the AST transformation logic.
# We can use placeholder variables for now.

var my_obj = nil # Placeholder
var data = 1
var config = 2
var a = 10
var b = 5
var first_obj = nil # Placeholder
var input = 100
var modifier = 10
var complex_obj = nil # Placeholder
var value = 50

# Example assignments to trigger parsing (if needed)
var temp1 = 1 # my_obj.process(data, config)
var temp2 = 2 # a.add(b)
var temp3 = 3 # first_obj.step_one(input).step_two(modifier)
var temp4 = 4 # complex_obj.settings.apply(value)

# No explicit main; this file is a UFCS transform showcase
