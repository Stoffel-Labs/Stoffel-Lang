//! Optimization passes for the Stoffel-Lang compiler.
//!
//! This module contains AST-level optimizations that improve the generated bytecode.

use crate::ast::AstNode;
use crate::errors::SourceLocation;
use std::collections::HashSet;
use std::sync::atomic::{AtomicUsize, Ordering};

/// Counter for generating unique temporary variable names
static BATCH_TEMP_COUNTER: AtomicUsize = AtomicUsize::new(0);

fn generate_temp_name() -> String {
    let count = BATCH_TEMP_COUNTER.fetch_add(1, Ordering::SeqCst);
    format!("__batch_reveal_{}", count)
}

/// Resets the temporary variable counter (useful for testing)
#[allow(dead_code)]
pub fn reset_temp_counter() {
    BATCH_TEMP_COUNTER.store(0, Ordering::SeqCst);
}

/// Represents a detected Share.open() call that can potentially be batched
#[derive(Debug, Clone)]
struct RevealCandidate {
    /// The index in the block where this statement appears
    statement_index: usize,
    /// The variable name being assigned to (if it's a variable declaration or assignment)
    target_var: Option<String>,
    /// The share expression being revealed (the argument to Share.open)
    share_expr: AstNode,
    /// Variables referenced in the share expression
    referenced_vars: HashSet<String>,
    /// The original statement node
    original_statement: AstNode,
    /// Source location for error reporting
    location: SourceLocation,
    /// Whether this is a variable declaration (vs assignment)
    is_declaration: bool,
    /// Type annotation if present (for declarations)
    type_annotation: Option<Box<AstNode>>,
    /// Whether the variable is mutable (for declarations)
    is_mutable: bool,
}

/// Collects all variable names referenced in an expression
fn collect_referenced_vars(node: &AstNode, vars: &mut HashSet<String>) {
    match node {
        AstNode::Identifier(name, _) => {
            vars.insert(name.clone());
        }
        AstNode::BinaryOperation { left, right, .. } => {
            collect_referenced_vars(left, vars);
            collect_referenced_vars(right, vars);
        }
        AstNode::UnaryOperation { operand, .. } => {
            collect_referenced_vars(operand, vars);
        }
        AstNode::FunctionCall { function, arguments, .. } => {
            collect_referenced_vars(function, vars);
            for arg in arguments {
                collect_referenced_vars(arg, vars);
            }
        }
        AstNode::FieldAccess { object, .. } => {
            collect_referenced_vars(object, vars);
        }
        AstNode::IndexAccess { base, index, .. } => {
            collect_referenced_vars(base, vars);
            collect_referenced_vars(index, vars);
        }
        AstNode::ListLiteral(elements) => {
            for elem in elements {
                collect_referenced_vars(elem, vars);
            }
        }
        AstNode::IfExpression { condition, then_branch, else_branch } => {
            collect_referenced_vars(condition, vars);
            collect_referenced_vars(then_branch, vars);
            if let Some(else_b) = else_branch {
                collect_referenced_vars(else_b, vars);
            }
        }
        _ => {}
    }
}

/// Checks if an AST node is a Share.open() function call
fn is_share_open_call(node: &AstNode) -> Option<&AstNode> {
    if let AstNode::FunctionCall { function, arguments, .. } = node {
        if let AstNode::Identifier(name, _) = function.as_ref() {
            if name == "Share.open" && arguments.len() == 1 {
                return Some(&arguments[0]);
            }
        }
    }
    None
}

/// Extracts reveal candidates from a block of statements
fn extract_reveal_candidates(statements: &[AstNode]) -> Vec<RevealCandidate> {
    let mut candidates = Vec::new();

    for (idx, stmt) in statements.iter().enumerate() {
        match stmt {
            // Pattern: let x = Share.open(share_expr)
            AstNode::VariableDeclaration { name, value: Some(value), type_annotation, is_mutable, location, .. } => {
                if let Some(share_expr) = is_share_open_call(value) {
                    let mut referenced_vars = HashSet::new();
                    collect_referenced_vars(share_expr, &mut referenced_vars);

                    candidates.push(RevealCandidate {
                        statement_index: idx,
                        target_var: Some(name.clone()),
                        share_expr: share_expr.clone(),
                        referenced_vars,
                        original_statement: stmt.clone(),
                        location: location.clone(),
                        is_declaration: true,
                        type_annotation: type_annotation.clone(),
                        is_mutable: *is_mutable,
                    });
                }
            }
            // Pattern: x = Share.open(share_expr)
            AstNode::Assignment { target, value, location } => {
                if let AstNode::Identifier(name, _) = target.as_ref() {
                    if let Some(share_expr) = is_share_open_call(value) {
                        let mut referenced_vars = HashSet::new();
                        collect_referenced_vars(share_expr, &mut referenced_vars);

                        candidates.push(RevealCandidate {
                            statement_index: idx,
                            target_var: Some(name.clone()),
                            share_expr: share_expr.clone(),
                            referenced_vars,
                            original_statement: stmt.clone(),
                            location: location.clone(),
                            is_declaration: false,
                            type_annotation: None,
                            is_mutable: false, // Not relevant for assignments
                        });
                    }
                }
            }
            // Pattern: _ = Share.open(share_expr) (discard statement)
            AstNode::DiscardStatement { expression, location } => {
                if let Some(share_expr) = is_share_open_call(expression) {
                    let mut referenced_vars = HashSet::new();
                    collect_referenced_vars(share_expr, &mut referenced_vars);

                    candidates.push(RevealCandidate {
                        statement_index: idx,
                        target_var: None,
                        share_expr: share_expr.clone(),
                        referenced_vars,
                        original_statement: stmt.clone(),
                        location: location.clone(),
                        is_declaration: false,
                        type_annotation: None,
                        is_mutable: false,
                    });
                }
            }
            _ => {}
        }
    }

    candidates
}

/// Groups consecutive reveal candidates that can be safely batched together.
/// Two reveals can be batched if:
/// 1. They are consecutive (no non-reveal statements between them)
/// 2. The second reveal doesn't reference any variable defined by the first
fn group_batchable_reveals(candidates: Vec<RevealCandidate>) -> Vec<Vec<RevealCandidate>> {
    if candidates.is_empty() {
        return Vec::new();
    }

    let mut groups: Vec<Vec<RevealCandidate>> = Vec::new();
    let mut current_group: Vec<RevealCandidate> = Vec::new();
    let mut defined_vars: HashSet<String> = HashSet::new();
    let mut last_index: Option<usize> = None;

    for candidate in candidates {
        let can_batch = match last_index {
            None => true,
            Some(last_idx) => {
                // Check if consecutive
                let is_consecutive = candidate.statement_index == last_idx + 1;
                // Check if there's no dependency on previously defined vars
                let has_dependency = candidate.referenced_vars.iter()
                    .any(|var| defined_vars.contains(var));

                is_consecutive && !has_dependency
            }
        };

        if can_batch {
            // Add to current group
            if let Some(ref var) = candidate.target_var {
                defined_vars.insert(var.clone());
            }
            current_group.push(candidate.clone());
            last_index = Some(candidate.statement_index);
        } else {
            // Start a new group
            if !current_group.is_empty() {
                groups.push(current_group);
            }
            defined_vars.clear();
            if let Some(ref var) = candidate.target_var {
                defined_vars.insert(var.clone());
            }
            current_group = vec![candidate.clone()];
            last_index = Some(candidate.statement_index);
        }
    }

    // Don't forget the last group
    if !current_group.is_empty() {
        groups.push(current_group);
    }

    groups
}

/// Creates a batch reveal transformation for a group of candidates
/// Transforms:
///   let a = Share.open(s1);
///   let b = Share.open(s2);
/// Into:
///   let __batch_reveal_N = Share.batch_open([s1, s2]);
///   let a = __batch_reveal_N[0];
///   let b = __batch_reveal_N[1];
fn create_batch_reveal_statements(group: &[RevealCandidate]) -> Vec<AstNode> {
    if group.len() < 2 {
        // Don't batch single reveals
        return group.iter().map(|c| c.original_statement.clone()).collect();
    }

    let temp_name = generate_temp_name();
    let location = group[0].location.clone();

    // Create the list of share expressions: [s1, s2, s3, ...]
    let share_list = AstNode::ListLiteral(
        group.iter().map(|c| c.share_expr.clone()).collect()
    );

    // Create: let __batch_reveal_N = Share.batch_open([s1, s2, ...])
    let batch_call = AstNode::FunctionCall {
        function: Box::new(AstNode::Identifier("Share.batch_open".to_string(), location.clone())),
        arguments: vec![share_list],
        location: location.clone(),
        resolved_return_type: None, // Will be resolved by semantic analysis
    };

    let batch_decl = AstNode::VariableDeclaration {
        name: temp_name.clone(),
        type_annotation: None,
        value: Some(Box::new(batch_call)),
        is_mutable: false,
        is_secret: false,
        location: location.clone(),
    };

    let mut result = vec![batch_decl];

    // Create index access statements for each original target
    for (idx, candidate) in group.iter().enumerate() {
        let index_access = AstNode::IndexAccess {
            base: Box::new(AstNode::Identifier(temp_name.clone(), location.clone())),
            index: Box::new(AstNode::Literal(crate::ast::Value::Int {
                value: idx as u128,
                kind: None
            })),
            location: candidate.location.clone(),
        };

        match (&candidate.target_var, candidate.is_declaration) {
            (Some(var_name), true) => {
                // Create: let var_name = __batch_reveal_N[idx]
                result.push(AstNode::VariableDeclaration {
                    name: var_name.clone(),
                    type_annotation: candidate.type_annotation.clone(),
                    value: Some(Box::new(index_access)),
                    is_mutable: candidate.is_mutable,
                    is_secret: false, // Result of reveal is not secret
                    location: candidate.location.clone(),
                });
            }
            (Some(var_name), false) => {
                // Create: var_name = __batch_reveal_N[idx]
                result.push(AstNode::Assignment {
                    target: Box::new(AstNode::Identifier(var_name.clone(), candidate.location.clone())),
                    value: Box::new(index_access),
                    location: candidate.location.clone(),
                });
            }
            (None, _) => {
                // Discard statement - create: _ = __batch_reveal_N[idx]
                result.push(AstNode::DiscardStatement {
                    expression: Box::new(index_access),
                    location: candidate.location.clone(),
                });
            }
        }
    }

    result
}

/// Optimizes a block by batching consecutive Share.open() calls
fn optimize_block(statements: Vec<AstNode>) -> Vec<AstNode> {
    // First, recursively optimize nested structures
    let statements: Vec<AstNode> = statements.into_iter()
        .map(optimize_reveals)
        .collect();

    // Extract reveal candidates
    let candidates = extract_reveal_candidates(&statements);

    if candidates.is_empty() {
        return statements;
    }

    // Group batchable reveals
    let groups = group_batchable_reveals(candidates);

    // Check if any batching is worthwhile (groups with 2+ candidates)
    let has_batchable = groups.iter().any(|g| g.len() >= 2);
    if !has_batchable {
        return statements;
    }

    // Build a set of statement indices that are part of batched groups
    let mut batched_indices: HashSet<usize> = HashSet::new();
    let mut batch_replacements: Vec<(usize, Vec<AstNode>)> = Vec::new();

    for group in &groups {
        if group.len() >= 2 {
            let first_idx = group[0].statement_index;
            for candidate in group {
                batched_indices.insert(candidate.statement_index);
            }
            batch_replacements.push((first_idx, create_batch_reveal_statements(group)));
        }
    }

    // Rebuild the statement list with batched reveals
    let mut result: Vec<AstNode> = Vec::new();
    let mut replacement_iter = batch_replacements.into_iter().peekable();

    for (idx, stmt) in statements.into_iter().enumerate() {
        if batched_indices.contains(&idx) {
            // Check if this is the first statement of a batch
            if let Some((first_idx, _)) = replacement_iter.peek() {
                if *first_idx == idx {
                    let (_, replacement_stmts) = replacement_iter.next().unwrap();
                    result.extend(replacement_stmts);
                }
            }
            // Skip other statements in the batch (they've been merged)
        } else {
            result.push(stmt);
        }
    }

    result
}

/// Main optimization entry point: batches consecutive Share.open() calls
/// to reduce network round trips by using Share.batch_open()
pub fn optimize_reveals(node: AstNode) -> AstNode {
    match node {
        AstNode::Block(statements) => {
            AstNode::Block(optimize_block(statements))
        }
        AstNode::FunctionDefinition { name, parameters, return_type, body, is_secret, pragmas, location, node_id } => {
            AstNode::FunctionDefinition {
                name,
                parameters,
                return_type,
                body: Box::new(optimize_reveals(*body)),
                is_secret,
                pragmas,
                location,
                node_id,
            }
        }
        AstNode::IfExpression { condition, then_branch, else_branch } => {
            AstNode::IfExpression {
                condition: Box::new(optimize_reveals(*condition)),
                then_branch: Box::new(optimize_reveals(*then_branch)),
                else_branch: else_branch.map(|e| Box::new(optimize_reveals(*e))),
            }
        }
        AstNode::WhileLoop { condition, body, location } => {
            AstNode::WhileLoop {
                condition: Box::new(optimize_reveals(*condition)),
                body: Box::new(optimize_reveals(*body)),
                location,
            }
        }
        AstNode::ForLoop { variables, iterable, body, location } => {
            AstNode::ForLoop {
                variables,
                iterable: Box::new(optimize_reveals(*iterable)),
                body: Box::new(optimize_reveals(*body)),
                location,
            }
        }
        AstNode::TryCatch { try_block, catch_clauses, finally_block, location } => {
            AstNode::TryCatch {
                try_block: Box::new(optimize_reveals(*try_block)),
                catch_clauses: catch_clauses.into_iter().map(|c| {
                    crate::ast::CatchClause {
                        body: Box::new(optimize_reveals(*c.body)),
                        ..c
                    }
                }).collect(),
                finally_block: finally_block.map(|b| Box::new(optimize_reveals(*b))),
                location,
            }
        }
        // Pass through other nodes unchanged
        _ => node,
    }
}

// =============================================================================
// INSTRUCTION REORDERING FOR IMPLICIT REVEAL BATCHING
// =============================================================================
//
// The VM's deferred reveal mechanism works as follows:
// 1. MOV clear_reg, secret_reg queues a PendingReveal
// 2. The reveal only flushes when the clear value is used in computation
//
// This optimization reorders statements to maximize batching by:
// - Grouping implicit reveals (secretâ†’clear assignments) together
// - Delaying computations that use revealed values until after all reveals
//
// Example transformation:
//   var a: int = secret1     // reveal a
//   var x = a * 2            // uses a - FLUSH! (only 1 reveal batched)
//   var b: int = secret2     // reveal b
//   var y = b * 3            // uses b - FLUSH! (only 1 reveal batched)
//
// Becomes:
//   var a: int = secret1     // reveal a - queued
//   var b: int = secret2     // reveal b - queued
//   var x = a * 2            // uses a - FLUSH! (both a and b batched)
//   var y = b * 3            // uses b - already revealed

use std::collections::HashMap;

/// Information about a statement for reordering purposes
#[derive(Debug, Clone)]
struct StatementInfo {
    /// Original index in the block
    index: usize,
    /// The AST node
    node: AstNode,
    /// Variables defined by this statement
    defines: HashSet<String>,
    /// Variables used/referenced by this statement
    uses: HashSet<String>,
    /// Is this an implicit reveal? (clear var = secret expr)
    is_implicit_reveal: bool,
    /// Does this statement use a revealed variable in a computation (triggers flush)?
    uses_revealed_var: bool,
}

/// Collects variables defined by a statement
fn collect_defined_vars(node: &AstNode) -> HashSet<String> {
    let mut defined = HashSet::new();
    match node {
        AstNode::VariableDeclaration { name, .. } => {
            defined.insert(name.clone());
        }
        AstNode::Assignment { target, .. } => {
            if let AstNode::Identifier(name, _) = target.as_ref() {
                defined.insert(name.clone());
            }
        }
        _ => {}
    }
    defined
}

/// Checks if a statement is an implicit reveal (clear variable assigned from secret)
fn is_implicit_reveal(node: &AstNode, secret_vars: &HashSet<String>) -> bool {
    match node {
        // var x: T = secret_var (where is_secret=false but value is secret)
        AstNode::VariableDeclaration { is_secret, value: Some(value), .. } => {
            if *is_secret {
                return false; // Secret var assigned from secret is not a reveal
            }
            // Check if the value references a secret variable
            let mut refs = HashSet::new();
            collect_referenced_vars(value, &mut refs);
            refs.iter().any(|v| secret_vars.contains(v))
        }
        // x = secret_var (assignment to clear var from secret)
        AstNode::Assignment { target, value, .. } => {
            if let AstNode::Identifier(name, _) = target.as_ref() {
                // If target is not secret and value references secret
                if secret_vars.contains(name) {
                    return false; // Secret var assigned from something
                }
                let mut refs = HashSet::new();
                collect_referenced_vars(value, &mut refs);
                refs.iter().any(|v| secret_vars.contains(v))
            } else {
                false
            }
        }
        _ => false,
    }
}

/// Checks if a statement uses a revealed variable in a way that triggers a flush
/// This happens when a revealed (clear) variable is used in computation
fn uses_revealed_in_computation(node: &AstNode, revealed_vars: &HashSet<String>) -> bool {
    match node {
        // Binary operations using revealed vars trigger flush
        AstNode::BinaryOperation { left, right, .. } => {
            let mut refs = HashSet::new();
            collect_referenced_vars(left, &mut refs);
            collect_referenced_vars(right, &mut refs);
            refs.iter().any(|v| revealed_vars.contains(v))
        }
        // Unary operations
        AstNode::UnaryOperation { operand, .. } => {
            let mut refs = HashSet::new();
            collect_referenced_vars(operand, &mut refs);
            refs.iter().any(|v| revealed_vars.contains(v))
        }
        // Function calls with revealed args
        AstNode::FunctionCall { arguments, .. } => {
            for arg in arguments {
                let mut refs = HashSet::new();
                collect_referenced_vars(arg, &mut refs);
                if refs.iter().any(|v| revealed_vars.contains(v)) {
                    return true;
                }
            }
            false
        }
        // Variable declarations with computation using revealed vars
        AstNode::VariableDeclaration { value: Some(value), .. } => {
            uses_revealed_in_computation(value, revealed_vars)
        }
        // Assignments with computation using revealed vars
        AstNode::Assignment { value, .. } => {
            uses_revealed_in_computation(value, revealed_vars)
        }
        // Discard statements
        AstNode::DiscardStatement { expression, .. } => {
            uses_revealed_in_computation(expression, revealed_vars)
        }
        _ => false,
    }
}

/// Builds dependency graph and reorders statements to maximize reveal batching
fn reorder_block_for_reveals(statements: Vec<AstNode>) -> Vec<AstNode> {
    if statements.len() < 2 {
        return statements;
    }

    // First pass: identify secret variables
    let mut secret_vars: HashSet<String> = HashSet::new();
    for stmt in &statements {
        if let AstNode::VariableDeclaration { name, is_secret: true, .. } = stmt {
            secret_vars.insert(name.clone());
        }
    }

    // If no secret variables, nothing to optimize
    if secret_vars.is_empty() {
        return statements;
    }

    // Second pass: build statement info
    let mut revealed_vars: HashSet<String> = HashSet::new();
    let mut stmt_infos: Vec<StatementInfo> = Vec::with_capacity(statements.len());

    for (index, node) in statements.into_iter().enumerate() {
        let defines = collect_defined_vars(&node);
        let mut uses = HashSet::new();

        // Collect uses based on node type
        match &node {
            AstNode::VariableDeclaration { value: Some(v), .. } => {
                collect_referenced_vars(v, &mut uses);
            }
            AstNode::Assignment { value, .. } => {
                collect_referenced_vars(value, &mut uses);
            }
            AstNode::DiscardStatement { expression, .. } => {
                collect_referenced_vars(expression, &mut uses);
            }
            AstNode::Return { value: Some(v), .. } => {
                collect_referenced_vars(v, &mut uses);
            }
            _ => {}
        }

        let is_reveal = is_implicit_reveal(&node, &secret_vars);

        // Track revealed variables
        if is_reveal {
            for def in &defines {
                revealed_vars.insert(def.clone());
            }
        }

        let uses_revealed = uses_revealed_in_computation(&node, &revealed_vars);

        stmt_infos.push(StatementInfo {
            index,
            node,
            defines,
            uses,
            is_implicit_reveal: is_reveal,
            uses_revealed_var: uses_revealed,
        });
    }

    // Check if reordering is beneficial
    let has_reveals = stmt_infos.iter().any(|s| s.is_implicit_reveal);
    let has_flush_triggers = stmt_infos.iter().any(|s| s.uses_revealed_var);

    if !has_reveals || !has_flush_triggers {
        return stmt_infos.into_iter().map(|s| s.node).collect();
    }

    // Build dependency map: for each statement, which statements must come before it?
    let mut must_precede: HashMap<usize, HashSet<usize>> = HashMap::new();
    let mut var_defined_at: HashMap<String, usize> = HashMap::new();

    for info in &stmt_infos {
        let mut predecessors = HashSet::new();

        // Statement depends on all statements that define variables it uses
        for used_var in &info.uses {
            if let Some(&def_idx) = var_defined_at.get(used_var) {
                predecessors.insert(def_idx);
            }
        }

        must_precede.insert(info.index, predecessors);

        // Record where each variable is defined
        for def_var in &info.defines {
            var_defined_at.insert(def_var.clone(), info.index);
        }
    }

    // Topological sort with preference:
    // 1. Reveals first (to batch them)
    // 2. Non-flush-triggering statements
    // 3. Flush-triggering statements last

    let mut result: Vec<AstNode> = Vec::with_capacity(stmt_infos.len());
    let mut scheduled: HashSet<usize> = HashSet::new();
    let mut remaining: Vec<usize> = (0..stmt_infos.len()).collect();

    while !remaining.is_empty() {
        // Find candidates that can be scheduled (all predecessors already scheduled)
        let mut candidates: Vec<usize> = remaining.iter()
            .filter(|&&idx| {
                must_precede.get(&idx)
                    .map(|preds| preds.iter().all(|p| scheduled.contains(p)))
                    .unwrap_or(true)
            })
            .copied()
            .collect();

        if candidates.is_empty() {
            // Cycle detected or error - just emit remaining in order
            for idx in remaining {
                result.push(stmt_infos[idx].node.clone());
            }
            break;
        }

        // Sort candidates by priority:
        // 1. Neutral statements first (includes secret declarations that feed into reveals)
        // 2. Reveals second (to group them together before flush triggers)
        // 3. Flush-triggering statements last (to allow maximum batching)
        candidates.sort_by(|&a, &b| {
            let info_a = &stmt_infos[a];
            let info_b = &stmt_infos[b];

            // Priority: neutral > reveal > flush_trigger
            // This ensures secret declarations come before reveals,
            // and reveals come before computations that use them
            let priority = |info: &StatementInfo| -> u8 {
                if info.uses_revealed_var { 2 }  // Flush triggers last
                else if info.is_implicit_reveal { 1 }  // Reveals second
                else { 0 }  // Neutral first (includes secret declarations)
            };

            let pa = priority(info_a);
            let pb = priority(info_b);

            if pa != pb {
                pa.cmp(&pb)
            } else {
                // Same priority: preserve original order
                a.cmp(&b)
            }
        });

        // Schedule the best candidate
        let best = candidates[0];
        result.push(stmt_infos[best].node.clone());
        scheduled.insert(best);
        remaining.retain(|&x| x != best);
    }

    result
}

/// Applies instruction reordering optimization to maximize implicit reveal batching
pub fn reorder_for_reveal_batching(node: AstNode) -> AstNode {
    match node {
        AstNode::Block(statements) => {
            // First recursively process nested structures
            let statements: Vec<AstNode> = statements.into_iter()
                .map(reorder_for_reveal_batching)
                .collect();
            // Then reorder this block
            AstNode::Block(reorder_block_for_reveals(statements))
        }
        AstNode::FunctionDefinition { name, parameters, return_type, body, is_secret, pragmas, location, node_id } => {
            AstNode::FunctionDefinition {
                name,
                parameters,
                return_type,
                body: Box::new(reorder_for_reveal_batching(*body)),
                is_secret,
                pragmas,
                location,
                node_id,
            }
        }
        AstNode::IfExpression { condition, then_branch, else_branch } => {
            AstNode::IfExpression {
                condition: Box::new(reorder_for_reveal_batching(*condition)),
                then_branch: Box::new(reorder_for_reveal_batching(*then_branch)),
                else_branch: else_branch.map(|e| Box::new(reorder_for_reveal_batching(*e))),
            }
        }
        AstNode::WhileLoop { condition, body, location } => {
            AstNode::WhileLoop {
                condition: Box::new(reorder_for_reveal_batching(*condition)),
                body: Box::new(reorder_for_reveal_batching(*body)),
                location,
            }
        }
        AstNode::ForLoop { variables, iterable, body, location } => {
            AstNode::ForLoop {
                variables,
                iterable: Box::new(reorder_for_reveal_batching(*iterable)),
                body: Box::new(reorder_for_reveal_batching(*body)),
                location,
            }
        }
        // Pass through other nodes unchanged
        _ => node,
    }
}

/// Combined optimization: applies both Share.open() batching and instruction reordering
pub fn optimize_all(node: AstNode) -> AstNode {
    let node = optimize_reveals(node);
    reorder_for_reveal_batching(node)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::AstNode;
    use crate::errors::SourceLocation;

    fn make_loc() -> SourceLocation {
        SourceLocation::default()
    }

    fn make_identifier(name: &str) -> AstNode {
        AstNode::Identifier(name.to_string(), make_loc())
    }

    fn make_share_open(share_expr: AstNode) -> AstNode {
        AstNode::FunctionCall {
            function: Box::new(make_identifier("Share.open")),
            arguments: vec![share_expr],
            location: make_loc(),
            resolved_return_type: None,
        }
    }

    fn make_var_decl(name: &str, value: AstNode) -> AstNode {
        AstNode::VariableDeclaration {
            name: name.to_string(),
            type_annotation: None,
            value: Some(Box::new(value)),
            is_mutable: false,
            is_secret: false,
            location: make_loc(),
        }
    }

    #[test]
    fn test_detect_share_open_call() {
        let share_expr = make_identifier("my_share");
        let open_call = make_share_open(share_expr.clone());

        let detected = is_share_open_call(&open_call);
        assert!(detected.is_some());
        assert_eq!(detected.unwrap(), &share_expr);
    }

    #[test]
    fn test_no_batch_single_reveal() {
        reset_temp_counter();

        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
        ]);

        let optimized = optimize_reveals(block);

        // Single reveal should not be batched
        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 1);
            // Should still be a VariableDeclaration with Share.open
            if let AstNode::VariableDeclaration { value: Some(val), .. } = &stmts[0] {
                assert!(is_share_open_call(val).is_some());
            } else {
                panic!("Expected VariableDeclaration");
            }
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_batch_two_reveals() {
        reset_temp_counter();

        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
            make_var_decl("b", make_share_open(make_identifier("s2"))),
        ]);

        let optimized = optimize_reveals(block);

        // Two reveals should be batched into 3 statements:
        // 1. let __batch_reveal_0 = Share.batch_open([s1, s2])
        // 2. let a = __batch_reveal_0[0]
        // 3. let b = __batch_reveal_0[1]
        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 3, "Expected 3 statements after batching");

            // First should be the batch call
            if let AstNode::VariableDeclaration { name, value: Some(val), .. } = &stmts[0] {
                assert!(name.starts_with("__batch_reveal_"), "Expected temp variable name");
                if let AstNode::FunctionCall { function, .. } = val.as_ref() {
                    if let AstNode::Identifier(fn_name, _) = function.as_ref() {
                        assert_eq!(fn_name, "Share.batch_open");
                    } else {
                        panic!("Expected identifier for function");
                    }
                } else {
                    panic!("Expected FunctionCall");
                }
            } else {
                panic!("Expected VariableDeclaration with batch call");
            }

            // Second should be index access for 'a'
            if let AstNode::VariableDeclaration { name, value: Some(val), .. } = &stmts[1] {
                assert_eq!(name, "a");
                assert!(matches!(val.as_ref(), AstNode::IndexAccess { .. }));
            } else {
                panic!("Expected VariableDeclaration for 'a'");
            }

            // Third should be index access for 'b'
            if let AstNode::VariableDeclaration { name, value: Some(val), .. } = &stmts[2] {
                assert_eq!(name, "b");
                assert!(matches!(val.as_ref(), AstNode::IndexAccess { .. }));
            } else {
                panic!("Expected VariableDeclaration for 'b'");
            }
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_no_batch_with_dependency() {
        reset_temp_counter();

        // b depends on a, so they can't be batched
        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
            make_var_decl("b", make_share_open(make_identifier("a"))), // depends on 'a'
        ]);

        let optimized = optimize_reveals(block);

        // Should not be batched due to dependency
        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 2, "Should not batch dependent reveals");
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_batch_three_reveals() {
        reset_temp_counter();

        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
            make_var_decl("b", make_share_open(make_identifier("s2"))),
            make_var_decl("c", make_share_open(make_identifier("s3"))),
        ]);

        let optimized = optimize_reveals(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 4, "Expected 4 statements after batching 3 reveals");
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_mixed_statements_partial_batch() {
        reset_temp_counter();

        // Mix of batchable and non-batchable statements
        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
            make_var_decl("b", make_share_open(make_identifier("s2"))),
            make_var_decl("x", make_identifier("something_else")), // Non-reveal
            make_var_decl("c", make_share_open(make_identifier("s3"))),
        ]);

        let optimized = optimize_reveals(block);

        if let AstNode::Block(stmts) = optimized {
            // Should batch first two, leave third alone, leave fourth alone (single)
            // Result: batch_decl, a, b, x, c (where c is not batched because it's alone)
            assert_eq!(stmts.len(), 5, "Expected 5 statements");
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_collect_referenced_vars() {
        let expr = AstNode::BinaryOperation {
            op: "+".to_string(),
            left: Box::new(make_identifier("x")),
            right: Box::new(make_identifier("y")),
            location: make_loc(),
        };

        let mut vars = HashSet::new();
        collect_referenced_vars(&expr, &mut vars);

        assert!(vars.contains("x"));
        assert!(vars.contains("y"));
        assert_eq!(vars.len(), 2);
    }

    // =======================================================================
    // Tests for instruction reordering optimization
    // =======================================================================

    fn make_secret_var_decl(name: &str, value: AstNode) -> AstNode {
        AstNode::VariableDeclaration {
            name: name.to_string(),
            type_annotation: None,
            value: Some(Box::new(value)),
            is_mutable: false,
            is_secret: true,  // Secret variable
            location: make_loc(),
        }
    }

    fn make_binary_op(left: AstNode, op: &str, right: AstNode) -> AstNode {
        AstNode::BinaryOperation {
            op: op.to_string(),
            left: Box::new(left),
            right: Box::new(right),
            location: make_loc(),
        }
    }

    fn get_var_decl_name(node: &AstNode) -> Option<&str> {
        if let AstNode::VariableDeclaration { name, .. } = node {
            Some(name.as_str())
        } else {
            None
        }
    }

    #[test]
    fn test_reorder_groups_reveals() {
        // Test that reveals are grouped before flush-triggering computations
        //
        // Input:
        //   secret var s1 = ...
        //   secret var s2 = ...
        //   var a: int = s1        // reveal
        //   var x = a * 2          // uses a - flush trigger
        //   var b: int = s2        // reveal
        //   var y = b * 3          // uses b - flush trigger
        //
        // Expected output (reordered):
        //   secret var s1 = ...
        //   secret var s2 = ...
        //   var a: int = s1        // reveal - queued
        //   var b: int = s2        // reveal - queued (moved up!)
        //   var x = a * 2          // uses a - flush (both batched)
        //   var y = b * 3          // uses b - already revealed

        let block = AstNode::Block(vec![
            make_secret_var_decl("s1", make_identifier("input1")),
            make_secret_var_decl("s2", make_identifier("input2")),
            make_var_decl("a", make_identifier("s1")),  // reveal
            make_var_decl("x", make_binary_op(make_identifier("a"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 2, kind: None }))),  // uses a
            make_var_decl("b", make_identifier("s2")),  // reveal
            make_var_decl("y", make_binary_op(make_identifier("b"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 3, kind: None }))),  // uses b
        ]);

        let optimized = reorder_for_reveal_batching(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 6);

            // First two should be secret declarations (unchanged)
            assert_eq!(get_var_decl_name(&stmts[0]), Some("s1"));
            assert_eq!(get_var_decl_name(&stmts[1]), Some("s2"));

            // Next two should be reveals (a and b grouped together)
            assert_eq!(get_var_decl_name(&stmts[2]), Some("a"));
            assert_eq!(get_var_decl_name(&stmts[3]), Some("b"));  // b moved up!

            // Last two should be the computations
            assert_eq!(get_var_decl_name(&stmts[4]), Some("x"));
            assert_eq!(get_var_decl_name(&stmts[5]), Some("y"));
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_reorder_respects_dependencies() {
        // Test that reordering respects data dependencies
        //
        // Input:
        //   secret var s1 = ...
        //   var a: int = s1        // reveal
        //   var x = a * 2          // depends on a
        //   var y = x + 1          // depends on x (chain dependency)
        //
        // x depends on a, y depends on x - order must be preserved

        let block = AstNode::Block(vec![
            make_secret_var_decl("s1", make_identifier("input1")),
            make_var_decl("a", make_identifier("s1")),  // reveal
            make_var_decl("x", make_binary_op(make_identifier("a"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 2, kind: None }))),
            make_var_decl("y", make_binary_op(make_identifier("x"), "+",
                AstNode::Literal(crate::ast::Value::Int { value: 1, kind: None }))),
        ]);

        let optimized = reorder_for_reveal_batching(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 4);

            // Order should be preserved due to dependencies
            assert_eq!(get_var_decl_name(&stmts[0]), Some("s1"));
            assert_eq!(get_var_decl_name(&stmts[1]), Some("a"));
            assert_eq!(get_var_decl_name(&stmts[2]), Some("x"));
            assert_eq!(get_var_decl_name(&stmts[3]), Some("y"));
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_reorder_independent_computation_after_reveals() {
        // Test that flush-triggering statements come after reveals and independent computations
        //
        // Input:
        //   secret var s1 = ...
        //   var a: int = s1        // reveal
        //   var z = 5 + 3          // independent computation
        //   var x = a * 2          // uses a (flush trigger)
        //
        // Order: neutral statements first (s1, z), then reveals (a), then flush triggers (x)
        // Note: z can come before or after a since neither depends on the other
        // The key is that x (which uses the revealed value) comes LAST

        let block = AstNode::Block(vec![
            make_secret_var_decl("s1", make_identifier("input1")),
            make_var_decl("a", make_identifier("s1")),  // reveal
            make_var_decl("z", make_binary_op(
                AstNode::Literal(crate::ast::Value::Int { value: 5, kind: None }),
                "+",
                AstNode::Literal(crate::ast::Value::Int { value: 3, kind: None }))),  // independent
            make_var_decl("x", make_binary_op(make_identifier("a"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 2, kind: None }))),  // uses a
        ]);

        let optimized = reorder_for_reveal_batching(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 4);

            // s1 must come first (defines the secret)
            assert_eq!(get_var_decl_name(&stmts[0]), Some("s1"));
            // z comes next (neutral, no dependencies)
            assert_eq!(get_var_decl_name(&stmts[1]), Some("z"));
            // a comes after s1 (reveal, depends on s1)
            assert_eq!(get_var_decl_name(&stmts[2]), Some("a"));
            // x must come last (uses revealed value - flush trigger)
            assert_eq!(get_var_decl_name(&stmts[3]), Some("x"));
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_no_reorder_without_secrets() {
        // Test that blocks without secret variables are not modified
        let block = AstNode::Block(vec![
            make_var_decl("a", make_identifier("x")),
            make_var_decl("b", make_identifier("y")),
            make_var_decl("c", make_binary_op(make_identifier("a"), "+", make_identifier("b"))),
        ]);

        let optimized = reorder_for_reveal_batching(block.clone());

        if let (AstNode::Block(original), AstNode::Block(opt)) = (block, optimized) {
            assert_eq!(original.len(), opt.len());
            // Order should be preserved
            for i in 0..original.len() {
                assert_eq!(get_var_decl_name(&original[i]), get_var_decl_name(&opt[i]));
            }
        } else {
            panic!("Expected Block");
        }
    }
}
