//! Optimization passes for the Stoffel-Lang compiler.
//!
//! This module contains AST-level optimizations that improve the generated bytecode.
//!
//! ## Optimization passes
//!
//! ### 1. `optimize_reveals` — Share.open() → batch_open batching
//! Groups consecutive `Share.open()` calls into `Share.batch_open()` to reduce network round trips.
//!
//! ### 2. `reorder_for_reveal_batching` — Instruction reordering for PendingReveal batching
//! The StoffelVM uses a deferred reveal model:
//! - **What creates PendingReveal**: `MOV clear_reg, secret_reg` — a clear variable assigned
//!   directly from a secret-producing expression (e.g., `let a: int = s` where `s` is secret).
//! - **What triggers flush**: Any instruction that reads a pending register forces the VM's
//!   `RevealBatcher` to flush all queued PendingReveal markers at once.
//! - **Why Share.open() is different**: `Share.open()` compiles to a CALL instruction that
//!   reveals immediately — no MOV secret→clear, no PendingReveal.
//!
//! This pass reorders statements to group PendingReveal-creating assignments together before
//! flush-triggering computations, maximizing the number of reveals batched per flush.

use crate::ast::AstNode;
use crate::errors::SourceLocation;
use std::collections::HashSet;
use std::sync::atomic::{AtomicUsize, Ordering};

/// Counter for generating unique temporary variable names
static BATCH_TEMP_COUNTER: AtomicUsize = AtomicUsize::new(0);

fn generate_temp_name() -> String {
    let count = BATCH_TEMP_COUNTER.fetch_add(1, Ordering::SeqCst);
    format!("__batch_reveal_{}", count)
}

/// Resets the temporary variable counter (useful for testing)
#[allow(dead_code)]
pub fn reset_temp_counter() {
    BATCH_TEMP_COUNTER.store(0, Ordering::SeqCst);
}

/// Represents a detected Share.open() call that can potentially be batched
#[derive(Debug, Clone)]
struct RevealCandidate {
    /// The index in the block where this statement appears
    statement_index: usize,
    /// The variable name being assigned to (if it's a variable declaration or assignment)
    target_var: Option<String>,
    /// The share expression being revealed (the argument to Share.open)
    share_expr: AstNode,
    /// Variables referenced in the share expression
    referenced_vars: HashSet<String>,
    /// The original statement node
    original_statement: AstNode,
    /// Source location for error reporting
    location: SourceLocation,
    /// Whether this is a variable declaration (vs assignment)
    is_declaration: bool,
    /// Type annotation if present (for declarations)
    type_annotation: Option<Box<AstNode>>,
    /// Whether the variable is mutable (for declarations)
    is_mutable: bool,
}

/// Collects all variable names referenced in an expression
fn collect_referenced_vars(node: &AstNode, vars: &mut HashSet<String>) {
    match node {
        AstNode::Identifier(name, _) => {
            vars.insert(name.clone());
        }
        AstNode::BinaryOperation { left, right, .. } => {
            collect_referenced_vars(left, vars);
            collect_referenced_vars(right, vars);
        }
        AstNode::UnaryOperation { operand, .. } => {
            collect_referenced_vars(operand, vars);
        }
        AstNode::FunctionCall { function, arguments, .. } => {
            collect_referenced_vars(function, vars);
            for arg in arguments {
                collect_referenced_vars(arg, vars);
            }
        }
        AstNode::FieldAccess { object, .. } => {
            collect_referenced_vars(object, vars);
        }
        AstNode::IndexAccess { base, index, .. } => {
            collect_referenced_vars(base, vars);
            collect_referenced_vars(index, vars);
        }
        AstNode::ListLiteral(elements) => {
            for elem in elements {
                collect_referenced_vars(elem, vars);
            }
        }
        AstNode::IfExpression { condition, then_branch, else_branch } => {
            collect_referenced_vars(condition, vars);
            collect_referenced_vars(then_branch, vars);
            if let Some(else_b) = else_branch {
                collect_referenced_vars(else_b, vars);
            }
        }
        _ => {}
    }
}

/// Checks if an AST node is a Share.open() function call
fn is_share_open_call(node: &AstNode) -> Option<&AstNode> {
    if let AstNode::FunctionCall { function, arguments, .. } = node {
        if let AstNode::Identifier(name, _) = function.as_ref() {
            if name == "Share.open" && arguments.len() == 1 {
                return Some(&arguments[0]);
            }
        }
    }
    None
}

/// Extracts reveal candidates from a block of statements
fn extract_reveal_candidates(statements: &[AstNode]) -> Vec<RevealCandidate> {
    let mut candidates = Vec::new();

    for (idx, stmt) in statements.iter().enumerate() {
        match stmt {
            // Pattern: let x = Share.open(share_expr)
            AstNode::VariableDeclaration { name, value: Some(value), type_annotation, is_mutable, location, .. } => {
                if let Some(share_expr) = is_share_open_call(value) {
                    let mut referenced_vars = HashSet::new();
                    collect_referenced_vars(share_expr, &mut referenced_vars);

                    candidates.push(RevealCandidate {
                        statement_index: idx,
                        target_var: Some(name.clone()),
                        share_expr: share_expr.clone(),
                        referenced_vars,
                        original_statement: stmt.clone(),
                        location: location.clone(),
                        is_declaration: true,
                        type_annotation: type_annotation.clone(),
                        is_mutable: *is_mutable,
                    });
                }
            }
            // Pattern: x = Share.open(share_expr)
            AstNode::Assignment { target, value, location } => {
                if let AstNode::Identifier(name, _) = target.as_ref() {
                    if let Some(share_expr) = is_share_open_call(value) {
                        let mut referenced_vars = HashSet::new();
                        collect_referenced_vars(share_expr, &mut referenced_vars);

                        candidates.push(RevealCandidate {
                            statement_index: idx,
                            target_var: Some(name.clone()),
                            share_expr: share_expr.clone(),
                            referenced_vars,
                            original_statement: stmt.clone(),
                            location: location.clone(),
                            is_declaration: false,
                            type_annotation: None,
                            is_mutable: false, // Not relevant for assignments
                        });
                    }
                }
            }
            // Pattern: _ = Share.open(share_expr) (discard statement)
            AstNode::DiscardStatement { expression, location } => {
                if let Some(share_expr) = is_share_open_call(expression) {
                    let mut referenced_vars = HashSet::new();
                    collect_referenced_vars(share_expr, &mut referenced_vars);

                    candidates.push(RevealCandidate {
                        statement_index: idx,
                        target_var: None,
                        share_expr: share_expr.clone(),
                        referenced_vars,
                        original_statement: stmt.clone(),
                        location: location.clone(),
                        is_declaration: false,
                        type_annotation: None,
                        is_mutable: false,
                    });
                }
            }
            _ => {}
        }
    }

    candidates
}

/// Groups consecutive reveal candidates that can be safely batched together.
/// Two reveals can be batched if:
/// 1. They are consecutive (no non-reveal statements between them)
/// 2. The second reveal doesn't reference any variable defined by the first
fn group_batchable_reveals(candidates: Vec<RevealCandidate>) -> Vec<Vec<RevealCandidate>> {
    if candidates.is_empty() {
        return Vec::new();
    }

    let mut groups: Vec<Vec<RevealCandidate>> = Vec::new();
    let mut current_group: Vec<RevealCandidate> = Vec::new();
    let mut defined_vars: HashSet<String> = HashSet::new();
    let mut last_index: Option<usize> = None;

    for candidate in candidates {
        let can_batch = match last_index {
            None => true,
            Some(last_idx) => {
                // Check if consecutive
                let is_consecutive = candidate.statement_index == last_idx + 1;
                // Check if there's no dependency on previously defined vars
                let has_dependency = candidate.referenced_vars.iter()
                    .any(|var| defined_vars.contains(var));

                is_consecutive && !has_dependency
            }
        };

        if can_batch {
            // Add to current group
            if let Some(ref var) = candidate.target_var {
                defined_vars.insert(var.clone());
            }
            current_group.push(candidate.clone());
            last_index = Some(candidate.statement_index);
        } else {
            // Start a new group
            if !current_group.is_empty() {
                groups.push(current_group);
            }
            defined_vars.clear();
            if let Some(ref var) = candidate.target_var {
                defined_vars.insert(var.clone());
            }
            current_group = vec![candidate.clone()];
            last_index = Some(candidate.statement_index);
        }
    }

    // Don't forget the last group
    if !current_group.is_empty() {
        groups.push(current_group);
    }

    groups
}

/// Creates a batch reveal transformation for a group of candidates
/// Transforms:
///   let a = Share.open(s1);
///   let b = Share.open(s2);
/// Into:
///   let __batch_reveal_N = Share.batch_open([s1, s2]);
///   let a = __batch_reveal_N[0];
///   let b = __batch_reveal_N[1];
fn create_batch_reveal_statements(group: &[RevealCandidate]) -> Vec<AstNode> {
    if group.len() < 2 {
        // Don't batch single reveals
        return group.iter().map(|c| c.original_statement.clone()).collect();
    }

    let temp_name = generate_temp_name();
    let location = group[0].location.clone();

    // Create the list of share expressions: [s1, s2, s3, ...]
    let share_list = AstNode::ListLiteral(
        group.iter().map(|c| c.share_expr.clone()).collect()
    );

    // Create: let __batch_reveal_N = Share.batch_open([s1, s2, ...])
    let batch_call = AstNode::FunctionCall {
        function: Box::new(AstNode::Identifier("Share.batch_open".to_string(), location.clone())),
        arguments: vec![share_list],
        location: location.clone(),
        resolved_return_type: None, // Will be resolved by semantic analysis
    };

    let batch_decl = AstNode::VariableDeclaration {
        name: temp_name.clone(),
        type_annotation: None,
        value: Some(Box::new(batch_call)),
        is_mutable: false,
        is_secret: false,
        location: location.clone(),
    };

    let mut result = vec![batch_decl];

    // Create index access statements for each original target
    for (idx, candidate) in group.iter().enumerate() {
        let index_access = AstNode::IndexAccess {
            base: Box::new(AstNode::Identifier(temp_name.clone(), location.clone())),
            index: Box::new(AstNode::Literal(crate::ast::Value::Int {
                value: idx as u128,
                kind: None
            })),
            location: candidate.location.clone(),
        };

        match (&candidate.target_var, candidate.is_declaration) {
            (Some(var_name), true) => {
                // Create: let var_name = __batch_reveal_N[idx]
                result.push(AstNode::VariableDeclaration {
                    name: var_name.clone(),
                    type_annotation: candidate.type_annotation.clone(),
                    value: Some(Box::new(index_access)),
                    is_mutable: candidate.is_mutable,
                    is_secret: false, // Result of reveal is not secret
                    location: candidate.location.clone(),
                });
            }
            (Some(var_name), false) => {
                // Create: var_name = __batch_reveal_N[idx]
                result.push(AstNode::Assignment {
                    target: Box::new(AstNode::Identifier(var_name.clone(), candidate.location.clone())),
                    value: Box::new(index_access),
                    location: candidate.location.clone(),
                });
            }
            (None, _) => {
                // Discard statement - create: _ = __batch_reveal_N[idx]
                result.push(AstNode::DiscardStatement {
                    expression: Box::new(index_access),
                    location: candidate.location.clone(),
                });
            }
        }
    }

    result
}

/// Optimizes a block by batching consecutive Share.open() calls
fn optimize_block(statements: Vec<AstNode>) -> Vec<AstNode> {
    // First, recursively optimize nested structures
    let statements: Vec<AstNode> = statements.into_iter()
        .map(optimize_reveals)
        .collect();

    // Extract reveal candidates
    let candidates = extract_reveal_candidates(&statements);

    if candidates.is_empty() {
        return statements;
    }

    // Group batchable reveals
    let groups = group_batchable_reveals(candidates);

    // Check if any batching is worthwhile (groups with 2+ candidates)
    let has_batchable = groups.iter().any(|g| g.len() >= 2);
    if !has_batchable {
        return statements;
    }

    // Build a set of statement indices that are part of batched groups
    let mut batched_indices: HashSet<usize> = HashSet::new();
    let mut batch_replacements: Vec<(usize, Vec<AstNode>)> = Vec::new();

    for group in &groups {
        if group.len() >= 2 {
            let first_idx = group[0].statement_index;
            for candidate in group {
                batched_indices.insert(candidate.statement_index);
            }
            batch_replacements.push((first_idx, create_batch_reveal_statements(group)));
        }
    }

    // Rebuild the statement list with batched reveals
    let mut result: Vec<AstNode> = Vec::new();
    let mut replacement_iter = batch_replacements.into_iter().peekable();

    for (idx, stmt) in statements.into_iter().enumerate() {
        if batched_indices.contains(&idx) {
            // Check if this is the first statement of a batch
            if let Some((first_idx, _)) = replacement_iter.peek() {
                if *first_idx == idx {
                    let (_, replacement_stmts) = replacement_iter.next().unwrap();
                    result.extend(replacement_stmts);
                }
            }
            // Skip other statements in the batch (they've been merged)
        } else {
            result.push(stmt);
        }
    }

    result
}

/// Main optimization entry point: batches consecutive Share.open() calls
/// to reduce network round trips by using Share.batch_open()
pub fn optimize_reveals(node: AstNode) -> AstNode {
    match node {
        AstNode::Block(statements) => {
            AstNode::Block(optimize_block(statements))
        }
        AstNode::FunctionDefinition { name, parameters, return_type, body, is_secret, pragmas, location, node_id } => {
            AstNode::FunctionDefinition {
                name,
                parameters,
                return_type,
                body: Box::new(optimize_reveals(*body)),
                is_secret,
                pragmas,
                location,
                node_id,
            }
        }
        AstNode::IfExpression { condition, then_branch, else_branch } => {
            AstNode::IfExpression {
                condition: Box::new(optimize_reveals(*condition)),
                then_branch: Box::new(optimize_reveals(*then_branch)),
                else_branch: else_branch.map(|e| Box::new(optimize_reveals(*e))),
            }
        }
        AstNode::WhileLoop { condition, body, location } => {
            AstNode::WhileLoop {
                condition: Box::new(optimize_reveals(*condition)),
                body: Box::new(optimize_reveals(*body)),
                location,
            }
        }
        AstNode::ForLoop { variables, iterable, body, location } => {
            AstNode::ForLoop {
                variables,
                iterable: Box::new(optimize_reveals(*iterable)),
                body: Box::new(optimize_reveals(*body)),
                location,
            }
        }
        AstNode::TryCatch { try_block, catch_clauses, finally_block, location } => {
            AstNode::TryCatch {
                try_block: Box::new(optimize_reveals(*try_block)),
                catch_clauses: catch_clauses.into_iter().map(|c| {
                    crate::ast::CatchClause {
                        body: Box::new(optimize_reveals(*c.body)),
                        ..c
                    }
                }).collect(),
                finally_block: finally_block.map(|b| Box::new(optimize_reveals(*b))),
                location,
            }
        }
        // Pass through other nodes unchanged
        _ => node,
    }
}

// =============================================================================
// INSTRUCTION REORDERING FOR PENDINGREVIEW BATCHING
// =============================================================================
//
// The VM's RevealBatcher uses a PendingReveal execution model:
//
// 1. MOV clear_reg, secret_reg → queues a PendingReveal marker (no network I/O yet)
// 2. Any instruction that READS a pending register → triggers flush of ALL pending reveals
// 3. Share.open() → compiles to CALL (immediate reveal, no PendingReveal)
//
// This optimization reorders statements to maximize batching by:
// - Grouping PendingReveal-creating assignments together before flush triggers
// - Tracking flush lifecycle: after a flush, pending vars become resolved and no longer
//   cause subsequent statements to be classified as flush triggers
//
// Example transformation:
//   var a: int = secret1     // creates PendingReveal for a
//   var x = a * 2            // reads a → FLUSH! (only 1 reveal batched)
//   var b: int = secret2     // creates PendingReveal for b
//   var y = b * 3            // reads b → FLUSH! (only 1 reveal batched)
//
// Becomes:
//   var a: int = secret1     // creates PendingReveal for a — queued
//   var b: int = secret2     // creates PendingReveal for b — queued
//   var x = a * 2            // reads a → FLUSH! (both a and b batched together)
//   var y = b * 3            // reads b — already resolved, no flush needed

use std::collections::HashMap;

/// Information about a statement for reordering purposes
#[derive(Debug, Clone)]
struct StatementInfo {
    /// Original index in the block
    index: usize,
    /// The AST node
    node: AstNode,
    /// Variables defined by this statement
    defines: HashSet<String>,
    /// Variables used/referenced by this statement
    uses: HashSet<String>,
    /// Does this statement create a PendingReveal? (clear var = secret-producing expr)
    creates_pending_reveal: bool,
}

/// Collects variables defined by a statement
fn collect_defined_vars(node: &AstNode) -> HashSet<String> {
    let mut defined = HashSet::new();
    match node {
        AstNode::VariableDeclaration { name, .. } => {
            defined.insert(name.clone());
        }
        AstNode::Assignment { target, .. } => {
            if let AstNode::Identifier(name, _) = target.as_ref() {
                defined.insert(name.clone());
            }
        }
        _ => {}
    }
    defined
}

/// Determines whether an expression will produce a value in a secret register after codegen.
///
/// Unlike `collect_referenced_vars` (which checks what variables an expression *references*),
/// this checks the **output type** of the expression. This distinction matters for function calls:
/// `Share.open(s)` references secret `s` but returns clear `Int64`, so it does NOT produce secret.
fn value_produces_secret(node: &AstNode, secret_vars: &HashSet<String>) -> bool {
    match node {
        AstNode::Identifier(name, _) => secret_vars.contains(name),
        AstNode::BinaryOperation { left, right, .. } => {
            value_produces_secret(left, secret_vars) || value_produces_secret(right, secret_vars)
        }
        AstNode::UnaryOperation { operand, .. } => {
            value_produces_secret(operand, secret_vars)
        }
        AstNode::FunctionCall { resolved_return_type, .. } => {
            // Check the resolved return type, NOT argument references.
            // Share.open() returns Int64 (clear), ClientStore.take_share() returns Secret(Int64).
            match resolved_return_type {
                Some(ty) => ty.is_secret(),
                None => false,
            }
        }
        AstNode::CommandCall { resolved_return_type, .. } => {
            match resolved_return_type {
                Some(ty) => ty.is_secret(),
                None => false,
            }
        }
        AstNode::Literal(_) => false,
        AstNode::IfExpression { then_branch, else_branch, .. } => {
            // Conservative: secret if either branch produces secret
            value_produces_secret(then_branch, secret_vars)
                || else_branch.as_ref().map_or(false, |e| value_produces_secret(e, secret_vars))
        }
        AstNode::FieldAccess { object, .. } => {
            value_produces_secret(object, secret_vars)
        }
        AstNode::IndexAccess { base, .. } => {
            value_produces_secret(base, secret_vars)
        }
        AstNode::Block(stmts) => {
            stmts.last().map_or(false, |last| value_produces_secret(last, secret_vars))
        }
        _ => false,
    }
}

/// Checks if a statement creates a PendingReveal in the VM (clear variable assigned from
/// a secret-producing expression, generating a MOV secret→clear instruction).
///
/// This uses `value_produces_secret` to check the **output type** of the value expression,
/// correctly excluding function calls like `Share.open()` that return clear values even
/// though they reference secret arguments.
fn creates_pending_reveal(node: &AstNode, secret_vars: &HashSet<String>) -> bool {
    match node {
        // var x: T = <secret-producing expr> (where is_secret=false)
        AstNode::VariableDeclaration { is_secret, value: Some(value), .. } => {
            if *is_secret {
                return false; // Secret var assigned from secret is not a reveal
            }
            value_produces_secret(value, secret_vars)
        }
        // x = <secret-producing expr> (assignment to clear var)
        AstNode::Assignment { target, value, .. } => {
            if let AstNode::Identifier(name, _) = target.as_ref() {
                if secret_vars.contains(name) {
                    return false; // Secret var assigned from something
                }
                value_produces_secret(value, secret_vars)
            } else {
                false
            }
        }
        _ => false,
    }
}

/// Checks if a statement reads a pending variable, triggering the VM to flush all pending reveals.
///
/// The `pending_vars` set contains variables that have been assigned via PendingReveal but not
/// yet flushed. When any instruction reads a pending register, the VM's RevealBatcher flushes
/// all queued reveals at once.
fn triggers_pending_flush(node: &AstNode, pending_vars: &HashSet<String>) -> bool {
    match node {
        AstNode::BinaryOperation { left, right, .. } => {
            let mut refs = HashSet::new();
            collect_referenced_vars(left, &mut refs);
            collect_referenced_vars(right, &mut refs);
            refs.iter().any(|v| pending_vars.contains(v))
        }
        AstNode::UnaryOperation { operand, .. } => {
            let mut refs = HashSet::new();
            collect_referenced_vars(operand, &mut refs);
            refs.iter().any(|v| pending_vars.contains(v))
        }
        AstNode::FunctionCall { arguments, .. } => {
            for arg in arguments {
                let mut refs = HashSet::new();
                collect_referenced_vars(arg, &mut refs);
                if refs.iter().any(|v| pending_vars.contains(v)) {
                    return true;
                }
            }
            false
        }
        AstNode::VariableDeclaration { value: Some(value), .. } => {
            triggers_pending_flush(value, pending_vars)
        }
        AstNode::Assignment { value, .. } => {
            triggers_pending_flush(value, pending_vars)
        }
        AstNode::DiscardStatement { expression, .. } => {
            triggers_pending_flush(expression, pending_vars)
        }
        _ => false,
    }
}

/// Builds dependency graph and reorders statements to maximize reveal batching.
///
/// Uses a greedy topological sort with dynamic flush classification and lifecycle tracking:
/// - `pending_vars`: variables with active PendingReveal markers (not yet flushed)
/// - `resolved_vars`: variables whose PendingReveal was already flushed
///
/// On each iteration, `triggers_flush` is computed dynamically against the current `pending_vars`.
/// After scheduling a flush trigger, all pending vars drain into `resolved_vars`, modeling the
/// VM flushing all pending reveals at once. This prevents previously-flushed variables from
/// incorrectly triggering subsequent flush classifications.
fn reorder_block_for_reveals(statements: Vec<AstNode>) -> Vec<AstNode> {
    if statements.len() < 2 {
        return statements;
    }

    // First pass: identify secret variables
    let mut secret_vars: HashSet<String> = HashSet::new();
    for stmt in &statements {
        if let AstNode::VariableDeclaration { name, is_secret: true, .. } = stmt {
            secret_vars.insert(name.clone());
        }
    }

    // If no secret variables, nothing to optimize
    if secret_vars.is_empty() {
        return statements;
    }

    // Second pass: build statement info (static classification only)
    let mut stmt_infos: Vec<StatementInfo> = Vec::with_capacity(statements.len());

    for (index, node) in statements.into_iter().enumerate() {
        let defines = collect_defined_vars(&node);
        let mut uses = HashSet::new();

        // Collect uses based on node type
        match &node {
            AstNode::VariableDeclaration { value: Some(v), .. } => {
                collect_referenced_vars(v, &mut uses);
            }
            AstNode::Assignment { value, .. } => {
                collect_referenced_vars(value, &mut uses);
            }
            AstNode::DiscardStatement { expression, .. } => {
                collect_referenced_vars(expression, &mut uses);
            }
            AstNode::Return { value: Some(v), .. } => {
                collect_referenced_vars(v, &mut uses);
            }
            _ => {}
        }

        let is_reveal = creates_pending_reveal(&node, &secret_vars);

        stmt_infos.push(StatementInfo {
            index,
            node,
            defines,
            uses,
            creates_pending_reveal: is_reveal,
        });
    }

    // Check if reordering is beneficial (flush triggers are computed dynamically)
    let has_reveals = stmt_infos.iter().any(|s| s.creates_pending_reveal);
    if !has_reveals {
        return stmt_infos.into_iter().map(|s| s.node).collect();
    }

    // Build dependency map: for each statement, which statements must come before it?
    let mut must_precede: HashMap<usize, HashSet<usize>> = HashMap::new();
    let mut var_defined_at: HashMap<String, usize> = HashMap::new();

    for info in &stmt_infos {
        let mut predecessors = HashSet::new();

        // Statement depends on all statements that define variables it uses
        for used_var in &info.uses {
            if let Some(&def_idx) = var_defined_at.get(used_var) {
                predecessors.insert(def_idx);
            }
        }

        must_precede.insert(info.index, predecessors);

        // Record where each variable is defined
        for def_var in &info.defines {
            var_defined_at.insert(def_var.clone(), info.index);
        }
    }

    // Topological sort with dynamic flush classification and lifecycle tracking:
    // Priority: neutral(0) → reveal(1) → flush-trigger(2), with original-order tiebreaking.

    let mut result: Vec<AstNode> = Vec::with_capacity(stmt_infos.len());
    let mut scheduled: HashSet<usize> = HashSet::new();
    let mut remaining: Vec<usize> = (0..stmt_infos.len()).collect();
    let mut pending_vars: HashSet<String> = HashSet::new();
    let mut _resolved_vars: HashSet<String> = HashSet::new();

    while !remaining.is_empty() {
        // Find candidates that can be scheduled (all predecessors already scheduled)
        let mut candidates: Vec<usize> = remaining.iter()
            .filter(|&&idx| {
                must_precede.get(&idx)
                    .map(|preds| preds.iter().all(|p| scheduled.contains(p)))
                    .unwrap_or(true)
            })
            .copied()
            .collect();

        if candidates.is_empty() {
            // Cycle detected or error - just emit remaining in order
            for idx in remaining {
                result.push(stmt_infos[idx].node.clone());
            }
            break;
        }

        // Sort candidates by dynamically computed priority:
        // 1. Neutral statements first (includes secret declarations)
        // 2. PendingReveal-creating statements second (to group them before flushes)
        // 3. Flush-triggering statements last (to allow maximum batching)
        candidates.sort_by(|&a, &b| {
            let info_a = &stmt_infos[a];
            let info_b = &stmt_infos[b];

            let priority = |info: &StatementInfo| -> u8 {
                // Dynamically check against current pending_vars
                if triggers_pending_flush(&info.node, &pending_vars) { 2 }
                else if info.creates_pending_reveal { 1 }
                else { 0 }
            };

            let pa = priority(info_a);
            let pb = priority(info_b);

            if pa != pb {
                pa.cmp(&pb)
            } else {
                // Same priority: preserve original order
                a.cmp(&b)
            }
        });

        // Schedule the best candidate
        let best = candidates[0];
        let best_info = &stmt_infos[best];

        // Flush lifecycle tracking
        if triggers_pending_flush(&best_info.node, &pending_vars) {
            // This statement triggers a flush: drain pending_vars into resolved_vars.
            // After flush, these variables are no longer "pending" in the VM.
            _resolved_vars.extend(pending_vars.drain());
        }

        if best_info.creates_pending_reveal {
            // This statement creates pending reveals: add defined vars to pending_vars
            for def in &best_info.defines {
                pending_vars.insert(def.clone());
            }
        }

        result.push(best_info.node.clone());
        scheduled.insert(best);
        remaining.retain(|&x| x != best);
    }

    result
}

/// Applies instruction reordering to maximize PendingReveal batching in the VM.
///
/// Reorders statements within blocks so that PendingReveal-creating assignments (MOV secret→clear)
/// are grouped together before any flush-triggering computation reads a pending register.
/// This allows the VM's RevealBatcher to batch multiple reveals into a single network round trip.
///
/// Note: `Share.open()` calls are NOT PendingReveal sources — they compile to immediate CALL
/// instructions. Only direct secret→clear variable assignments create PendingReveal markers.
pub fn reorder_for_reveal_batching(node: AstNode) -> AstNode {
    match node {
        AstNode::Block(statements) => {
            // First recursively process nested structures
            let statements: Vec<AstNode> = statements.into_iter()
                .map(reorder_for_reveal_batching)
                .collect();
            // Then reorder this block
            AstNode::Block(reorder_block_for_reveals(statements))
        }
        AstNode::FunctionDefinition { name, parameters, return_type, body, is_secret, pragmas, location, node_id } => {
            AstNode::FunctionDefinition {
                name,
                parameters,
                return_type,
                body: Box::new(reorder_for_reveal_batching(*body)),
                is_secret,
                pragmas,
                location,
                node_id,
            }
        }
        AstNode::IfExpression { condition, then_branch, else_branch } => {
            AstNode::IfExpression {
                condition: Box::new(reorder_for_reveal_batching(*condition)),
                then_branch: Box::new(reorder_for_reveal_batching(*then_branch)),
                else_branch: else_branch.map(|e| Box::new(reorder_for_reveal_batching(*e))),
            }
        }
        AstNode::WhileLoop { condition, body, location } => {
            AstNode::WhileLoop {
                condition: Box::new(reorder_for_reveal_batching(*condition)),
                body: Box::new(reorder_for_reveal_batching(*body)),
                location,
            }
        }
        AstNode::ForLoop { variables, iterable, body, location } => {
            AstNode::ForLoop {
                variables,
                iterable: Box::new(reorder_for_reveal_batching(*iterable)),
                body: Box::new(reorder_for_reveal_batching(*body)),
                location,
            }
        }
        // Pass through other nodes unchanged
        _ => node,
    }
}

/// Combined optimization: applies both Share.open()→batch_open batching and PendingReveal
/// instruction reordering. The two passes are independent and compose cleanly.
pub fn optimize_all(node: AstNode) -> AstNode {
    let node = optimize_reveals(node);
    reorder_for_reveal_batching(node)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::AstNode;
    use crate::errors::SourceLocation;
    use crate::symbol_table::SymbolType;

    fn make_loc() -> SourceLocation {
        SourceLocation::default()
    }

    fn make_identifier(name: &str) -> AstNode {
        AstNode::Identifier(name.to_string(), make_loc())
    }

    fn make_share_open(share_expr: AstNode) -> AstNode {
        AstNode::FunctionCall {
            function: Box::new(make_identifier("Share.open")),
            arguments: vec![share_expr],
            location: make_loc(),
            resolved_return_type: Some(SymbolType::Int64),
        }
    }

    fn make_var_decl(name: &str, value: AstNode) -> AstNode {
        AstNode::VariableDeclaration {
            name: name.to_string(),
            type_annotation: None,
            value: Some(Box::new(value)),
            is_mutable: false,
            is_secret: false,
            location: make_loc(),
        }
    }

    #[test]
    fn test_detect_share_open_call() {
        let share_expr = make_identifier("my_share");
        let open_call = make_share_open(share_expr.clone());

        let detected = is_share_open_call(&open_call);
        assert!(detected.is_some());
        assert_eq!(detected.unwrap(), &share_expr);
    }

    #[test]
    fn test_no_batch_single_reveal() {
        reset_temp_counter();

        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
        ]);

        let optimized = optimize_reveals(block);

        // Single reveal should not be batched
        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 1);
            // Should still be a VariableDeclaration with Share.open
            if let AstNode::VariableDeclaration { value: Some(val), .. } = &stmts[0] {
                assert!(is_share_open_call(val).is_some());
            } else {
                panic!("Expected VariableDeclaration");
            }
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_batch_two_reveals() {
        reset_temp_counter();

        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
            make_var_decl("b", make_share_open(make_identifier("s2"))),
        ]);

        let optimized = optimize_reveals(block);

        // Two reveals should be batched into 3 statements:
        // 1. let __batch_reveal_0 = Share.batch_open([s1, s2])
        // 2. let a = __batch_reveal_0[0]
        // 3. let b = __batch_reveal_0[1]
        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 3, "Expected 3 statements after batching");

            // First should be the batch call
            if let AstNode::VariableDeclaration { name, value: Some(val), .. } = &stmts[0] {
                assert!(name.starts_with("__batch_reveal_"), "Expected temp variable name");
                if let AstNode::FunctionCall { function, .. } = val.as_ref() {
                    if let AstNode::Identifier(fn_name, _) = function.as_ref() {
                        assert_eq!(fn_name, "Share.batch_open");
                    } else {
                        panic!("Expected identifier for function");
                    }
                } else {
                    panic!("Expected FunctionCall");
                }
            } else {
                panic!("Expected VariableDeclaration with batch call");
            }

            // Second should be index access for 'a'
            if let AstNode::VariableDeclaration { name, value: Some(val), .. } = &stmts[1] {
                assert_eq!(name, "a");
                assert!(matches!(val.as_ref(), AstNode::IndexAccess { .. }));
            } else {
                panic!("Expected VariableDeclaration for 'a'");
            }

            // Third should be index access for 'b'
            if let AstNode::VariableDeclaration { name, value: Some(val), .. } = &stmts[2] {
                assert_eq!(name, "b");
                assert!(matches!(val.as_ref(), AstNode::IndexAccess { .. }));
            } else {
                panic!("Expected VariableDeclaration for 'b'");
            }
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_no_batch_with_dependency() {
        reset_temp_counter();

        // b depends on a, so they can't be batched
        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
            make_var_decl("b", make_share_open(make_identifier("a"))), // depends on 'a'
        ]);

        let optimized = optimize_reveals(block);

        // Should not be batched due to dependency
        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 2, "Should not batch dependent reveals");
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_batch_three_reveals() {
        reset_temp_counter();

        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
            make_var_decl("b", make_share_open(make_identifier("s2"))),
            make_var_decl("c", make_share_open(make_identifier("s3"))),
        ]);

        let optimized = optimize_reveals(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 4, "Expected 4 statements after batching 3 reveals");
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_mixed_statements_partial_batch() {
        reset_temp_counter();

        // Mix of batchable and non-batchable statements
        let block = AstNode::Block(vec![
            make_var_decl("a", make_share_open(make_identifier("s1"))),
            make_var_decl("b", make_share_open(make_identifier("s2"))),
            make_var_decl("x", make_identifier("something_else")), // Non-reveal
            make_var_decl("c", make_share_open(make_identifier("s3"))),
        ]);

        let optimized = optimize_reveals(block);

        if let AstNode::Block(stmts) = optimized {
            // Should batch first two, leave third alone, leave fourth alone (single)
            // Result: batch_decl, a, b, x, c (where c is not batched because it's alone)
            assert_eq!(stmts.len(), 5, "Expected 5 statements");
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_collect_referenced_vars() {
        let expr = AstNode::BinaryOperation {
            op: "+".to_string(),
            left: Box::new(make_identifier("x")),
            right: Box::new(make_identifier("y")),
            location: make_loc(),
        };

        let mut vars = HashSet::new();
        collect_referenced_vars(&expr, &mut vars);

        assert!(vars.contains("x"));
        assert!(vars.contains("y"));
        assert_eq!(vars.len(), 2);
    }

    // =======================================================================
    // Tests for instruction reordering optimization
    // =======================================================================

    fn make_secret_var_decl(name: &str, value: AstNode) -> AstNode {
        AstNode::VariableDeclaration {
            name: name.to_string(),
            type_annotation: None,
            value: Some(Box::new(value)),
            is_mutable: false,
            is_secret: true,  // Secret variable
            location: make_loc(),
        }
    }

    fn make_binary_op(left: AstNode, op: &str, right: AstNode) -> AstNode {
        AstNode::BinaryOperation {
            op: op.to_string(),
            left: Box::new(left),
            right: Box::new(right),
            location: make_loc(),
        }
    }

    fn get_var_decl_name(node: &AstNode) -> Option<&str> {
        if let AstNode::VariableDeclaration { name, .. } = node {
            Some(name.as_str())
        } else {
            None
        }
    }

    #[test]
    fn test_reorder_groups_reveals() {
        // Test that reveals are grouped before flush-triggering computations
        //
        // Input:
        //   secret var s1 = ...
        //   secret var s2 = ...
        //   var a: int = s1        // reveal
        //   var x = a * 2          // uses a - flush trigger
        //   var b: int = s2        // reveal
        //   var y = b * 3          // uses b - flush trigger
        //
        // Expected output (reordered):
        //   secret var s1 = ...
        //   secret var s2 = ...
        //   var a: int = s1        // reveal - queued
        //   var b: int = s2        // reveal - queued (moved up!)
        //   var x = a * 2          // uses a - flush (both batched)
        //   var y = b * 3          // uses b - already revealed

        let block = AstNode::Block(vec![
            make_secret_var_decl("s1", make_identifier("input1")),
            make_secret_var_decl("s2", make_identifier("input2")),
            make_var_decl("a", make_identifier("s1")),  // reveal
            make_var_decl("x", make_binary_op(make_identifier("a"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 2, kind: None }))),  // uses a
            make_var_decl("b", make_identifier("s2")),  // reveal
            make_var_decl("y", make_binary_op(make_identifier("b"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 3, kind: None }))),  // uses b
        ]);

        let optimized = reorder_for_reveal_batching(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 6);

            // First two should be secret declarations (unchanged)
            assert_eq!(get_var_decl_name(&stmts[0]), Some("s1"));
            assert_eq!(get_var_decl_name(&stmts[1]), Some("s2"));

            // Next two should be reveals (a and b grouped together)
            assert_eq!(get_var_decl_name(&stmts[2]), Some("a"));
            assert_eq!(get_var_decl_name(&stmts[3]), Some("b"));  // b moved up!

            // Last two should be the computations
            assert_eq!(get_var_decl_name(&stmts[4]), Some("x"));
            assert_eq!(get_var_decl_name(&stmts[5]), Some("y"));
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_reorder_respects_dependencies() {
        // Test that reordering respects data dependencies
        //
        // Input:
        //   secret var s1 = ...
        //   var a: int = s1        // reveal
        //   var x = a * 2          // depends on a
        //   var y = x + 1          // depends on x (chain dependency)
        //
        // x depends on a, y depends on x - order must be preserved

        let block = AstNode::Block(vec![
            make_secret_var_decl("s1", make_identifier("input1")),
            make_var_decl("a", make_identifier("s1")),  // reveal
            make_var_decl("x", make_binary_op(make_identifier("a"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 2, kind: None }))),
            make_var_decl("y", make_binary_op(make_identifier("x"), "+",
                AstNode::Literal(crate::ast::Value::Int { value: 1, kind: None }))),
        ]);

        let optimized = reorder_for_reveal_batching(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 4);

            // Order should be preserved due to dependencies
            assert_eq!(get_var_decl_name(&stmts[0]), Some("s1"));
            assert_eq!(get_var_decl_name(&stmts[1]), Some("a"));
            assert_eq!(get_var_decl_name(&stmts[2]), Some("x"));
            assert_eq!(get_var_decl_name(&stmts[3]), Some("y"));
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_reorder_independent_computation_after_reveals() {
        // Test that flush-triggering statements come after reveals and independent computations
        //
        // Input:
        //   secret var s1 = ...
        //   var a: int = s1        // reveal
        //   var z = 5 + 3          // independent computation
        //   var x = a * 2          // uses a (flush trigger)
        //
        // Order: neutral statements first (s1, z), then reveals (a), then flush triggers (x)
        // Note: z can come before or after a since neither depends on the other
        // The key is that x (which uses the revealed value) comes LAST

        let block = AstNode::Block(vec![
            make_secret_var_decl("s1", make_identifier("input1")),
            make_var_decl("a", make_identifier("s1")),  // reveal
            make_var_decl("z", make_binary_op(
                AstNode::Literal(crate::ast::Value::Int { value: 5, kind: None }),
                "+",
                AstNode::Literal(crate::ast::Value::Int { value: 3, kind: None }))),  // independent
            make_var_decl("x", make_binary_op(make_identifier("a"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 2, kind: None }))),  // uses a
        ]);

        let optimized = reorder_for_reveal_batching(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 4);

            // s1 must come first (defines the secret)
            assert_eq!(get_var_decl_name(&stmts[0]), Some("s1"));
            // z comes next (neutral, no dependencies)
            assert_eq!(get_var_decl_name(&stmts[1]), Some("z"));
            // a comes after s1 (reveal, depends on s1)
            assert_eq!(get_var_decl_name(&stmts[2]), Some("a"));
            // x must come last (uses revealed value - flush trigger)
            assert_eq!(get_var_decl_name(&stmts[3]), Some("x"));
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_no_reorder_without_secrets() {
        // Test that blocks without secret variables are not modified
        let block = AstNode::Block(vec![
            make_var_decl("a", make_identifier("x")),
            make_var_decl("b", make_identifier("y")),
            make_var_decl("c", make_binary_op(make_identifier("a"), "+", make_identifier("b"))),
        ]);

        let optimized = reorder_for_reveal_batching(block.clone());

        if let (AstNode::Block(original), AstNode::Block(opt)) = (block, optimized) {
            assert_eq!(original.len(), opt.len());
            // Order should be preserved
            for i in 0..original.len() {
                assert_eq!(get_var_decl_name(&original[i]), get_var_decl_name(&opt[i]));
            }
        } else {
            panic!("Expected Block");
        }
    }

    // =======================================================================
    // Tests for value_produces_secret helper
    // =======================================================================

    #[test]
    fn test_value_produces_secret_identifier() {
        let mut secret_vars = HashSet::new();
        secret_vars.insert("s1".to_string());

        assert!(value_produces_secret(&make_identifier("s1"), &secret_vars));
        assert!(!value_produces_secret(&make_identifier("x"), &secret_vars));
    }

    #[test]
    fn test_value_produces_secret_binary_op() {
        let mut secret_vars = HashSet::new();
        secret_vars.insert("s1".to_string());

        // Secret + literal → secret
        let expr = make_binary_op(
            make_identifier("s1"),
            "+",
            AstNode::Literal(crate::ast::Value::Int { value: 1, kind: None }),
        );
        assert!(value_produces_secret(&expr, &secret_vars));

        // Clear + clear → clear
        let expr2 = make_binary_op(
            make_identifier("x"),
            "+",
            AstNode::Literal(crate::ast::Value::Int { value: 1, kind: None }),
        );
        assert!(!value_produces_secret(&expr2, &secret_vars));
    }

    #[test]
    fn test_value_produces_secret_function_call_clear_return() {
        let secret_vars = HashSet::new();

        // Share.open() returns Int64 (clear) — NOT secret even though it takes secret args
        let call = AstNode::FunctionCall {
            function: Box::new(make_identifier("Share.open")),
            arguments: vec![make_identifier("s1")],
            location: make_loc(),
            resolved_return_type: Some(SymbolType::Int64),
        };
        assert!(!value_produces_secret(&call, &secret_vars));
    }

    #[test]
    fn test_value_produces_secret_function_call_secret_return() {
        let secret_vars = HashSet::new();

        // ClientStore.take_share() returns Secret(Int64) — IS secret
        let call = AstNode::FunctionCall {
            function: Box::new(make_identifier("ClientStore.take_share")),
            arguments: vec![make_identifier("x")],
            location: make_loc(),
            resolved_return_type: Some(SymbolType::Secret(Box::new(SymbolType::Int64))),
        };
        assert!(value_produces_secret(&call, &secret_vars));
    }

    #[test]
    fn test_value_produces_secret_literal() {
        let secret_vars = HashSet::new();
        let lit = AstNode::Literal(crate::ast::Value::Int { value: 42, kind: None });
        assert!(!value_produces_secret(&lit, &secret_vars));
    }

    // =======================================================================
    // Tests for PendingReveal classification fixes
    // =======================================================================

    #[test]
    fn test_share_open_not_pending_reveal() {
        // let a = Share.open(s1) should NOT be classified as a PendingReveal
        // because Share.open() returns Int64 (clear), compiling to CALL not MOV
        let mut secret_vars = HashSet::new();
        secret_vars.insert("s1".to_string());

        let stmt = make_var_decl("a", AstNode::FunctionCall {
            function: Box::new(make_identifier("Share.open")),
            arguments: vec![make_identifier("s1")],
            location: make_loc(),
            resolved_return_type: Some(SymbolType::Int64),
        });

        assert!(!creates_pending_reveal(&stmt, &secret_vars));
    }

    #[test]
    fn test_share_open_treated_as_neutral_for_reordering() {
        // Share.open(s1) should be treated as neutral (not a reveal) for reordering,
        // so it doesn't get grouped with actual PendingReveal statements
        let block = AstNode::Block(vec![
            make_secret_var_decl("s1", make_identifier("input1")),
            make_secret_var_decl("s2", make_identifier("input2")),
            // Share.open is a function call that returns clear — not a PendingReveal
            make_var_decl("a", AstNode::FunctionCall {
                function: Box::new(make_identifier("Share.open")),
                arguments: vec![make_identifier("s1")],
                location: make_loc(),
                resolved_return_type: Some(SymbolType::Int64),
            }),
            make_var_decl("b", make_identifier("s2")),  // actual PendingReveal
            make_var_decl("x", make_binary_op(make_identifier("b"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 2, kind: None }))),
        ]);

        let optimized = reorder_for_reveal_batching(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 5);
            // s1, s2 first (neutral secret declarations)
            assert_eq!(get_var_decl_name(&stmts[0]), Some("s1"));
            assert_eq!(get_var_decl_name(&stmts[1]), Some("s2"));
            // a (Share.open) is neutral — comes before or with reveals
            // b is the PendingReveal
            // x is the flush trigger, must come last
            assert_eq!(get_var_decl_name(&stmts[4]), Some("x"));
        } else {
            panic!("Expected Block");
        }
    }

    #[test]
    fn test_pending_queue_resets_after_flush() {
        // After a flush trigger resolves all pending reveals, subsequent use of those
        // variables should be neutral (not flush triggers). Tests multi-batch scenario.
        //
        // Input:
        //   secret var s1 = ...
        //   secret var s2 = ...
        //   var a = s1              // PendingReveal for a
        //   var x = a * 2           // reads a → FLUSH (a resolved)
        //   var b = s2              // PendingReveal for b
        //   var y = a + b           // reads a (resolved, not pending!) and b (pending) → FLUSH
        //
        // After reordering, a and b should ideally be grouped before x and y.
        // The key test: after x flushes, 'a' is no longer pending, so a statement
        // using only 'a' after the flush would NOT be a flush trigger.

        let block = AstNode::Block(vec![
            make_secret_var_decl("s1", make_identifier("input1")),
            make_secret_var_decl("s2", make_identifier("input2")),
            make_var_decl("a", make_identifier("s1")),  // PendingReveal
            make_var_decl("x", make_binary_op(make_identifier("a"), "*",
                AstNode::Literal(crate::ast::Value::Int { value: 2, kind: None }))),  // flush trigger
            make_var_decl("b", make_identifier("s2")),  // PendingReveal
            make_var_decl("y", make_binary_op(make_identifier("a"), "+", make_identifier("b"))),  // flush trigger
        ]);

        let optimized = reorder_for_reveal_batching(block);

        if let AstNode::Block(stmts) = optimized {
            assert_eq!(stmts.len(), 6);

            // Secret declarations first
            assert_eq!(get_var_decl_name(&stmts[0]), Some("s1"));
            assert_eq!(get_var_decl_name(&stmts[1]), Some("s2"));

            // Both reveals should be grouped together before flush triggers
            assert_eq!(get_var_decl_name(&stmts[2]), Some("a"));
            assert_eq!(get_var_decl_name(&stmts[3]), Some("b"));

            // Flush triggers last
            assert_eq!(get_var_decl_name(&stmts[4]), Some("x"));
            assert_eq!(get_var_decl_name(&stmts[5]), Some("y"));
        } else {
            panic!("Expected Block");
        }
    }
}
