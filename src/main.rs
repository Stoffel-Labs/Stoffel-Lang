use std::fs;
use std::path::Path;
use std::process;

use clap::Parser as ClapParser; // Alias to avoid name clash with our parser module

mod ast;
mod core_types;
mod bytecode;
mod codegen;
mod compiler;
mod lexer;
mod errors;
mod parser;
mod symbol_table;
mod semantic;
mod suggestions;
mod ufcs;
mod register_allocator;
mod binary_converter;

/// Stoffel Language Compiler
#[derive(ClapParser, Debug)]
#[command(author, version, about, long_about = None)]
struct CliArgs {
    /// The source file to compile or the binary to disassemble
    #[arg(required = true)]
    filename: String,

    /// Output binary file path
    #[arg(short, long)]
    output: Option<String>,

    /// Generate VM-compatible binary
    #[arg(short = 'b', long)]
    binary: bool,

    /// Disassemble a compiled Stoffel binary (.stfl) instead of compiling source
    #[arg(long, action = clap::ArgAction::SetTrue)]
    disassemble: bool,

    /// Print intermediate representations (Tokens, AST)
    #[arg(long)]
    print_ir: bool,

    /// Set optimization level (0-3). Accepts `-O3` or `-O 3`.
    #[arg(short = 'O', long = "opt-level",
          default_value_t = 0,
          value_parser = clap::value_parser!(u8).range(0..=3),
          value_name = "N")]
    opt_level: u8,

    /// Enable optimizations (shorthand for -O2)
    #[arg(long, action = clap::ArgAction::SetTrue, conflicts_with = "opt_level")]
    optimize: bool,
}

fn dedupe_constants_for_display(constants: &[bytecode::Constant]) -> Vec<bytecode::Constant> {
    use std::collections::HashSet;
    let mut seen: HashSet<crate::core_types::Value> = HashSet::new();
    let mut out = Vec::with_capacity(constants.len());
    for c in constants.iter().cloned() {
        let v: crate::core_types::Value = crate::core_types::Value::from(c.clone());
        if seen.insert(v) {
            out.push(c);
        }
    }
    out
}

fn main() {
    let args = CliArgs::parse();

    let filename = &args.filename;

    // Disassemble mode: read binary and print human-readable disassembly
    if args.disassemble {
        match binary_converter::load_from_file(filename) {
            Ok(bin) => {
                let text = binary_converter::disassemble(&bin);
                println!("{}", text);
                return;
            }
            Err(e) => {
                eprintln!("Error loading binary '{}': {:?}", filename, e);
                process::exit(1);
            }
        }
    }

    let source = match fs::read_to_string(filename) {
        Ok(s) => s,
        Err(e) => {
            eprintln!("Error reading file '{}': {}", filename, e);
            process::exit(1);
        }
    };

    let file_path = Path::new(filename);
    let file_name = file_path.file_name().unwrap_or_default().to_string_lossy().to_string();

    let options = compiler::CompilerOptions {
        optimize: args.optimize,
        optimization_level: args.opt_level,
        print_ir: args.print_ir,
    };

    println!("Compiling {}...", filename);

    match compiler::compile(&source, &file_name, &options) {
        Ok(compiled_program) => {
            println!("Compilation successful!");

            if args.print_ir {
                println!("\n--- Generated Bytecode ---");
                println!("Main Chunk:");
                println!("  Constants: {:?}", dedupe_constants_for_display(&compiled_program.main_chunk.constants));
                println!("  Instructions:");
                for (i, instruction) in compiled_program.main_chunk.instructions.iter().enumerate() {
                    println!("{:04}: {:?}", i, instruction);
                }
                println!("  Labels: {:?}", compiled_program.main_chunk.labels);

                if !compiled_program.function_chunks.is_empty() {
                    println!("\nCompiled Functions:");

                    // Sort function names for deterministic output
                    let mut names: Vec<_> = compiled_program.function_chunks.keys().cloned().collect();
                    names.sort();
                    for name in names {
                        if let Some(chunk) = compiled_program.function_chunks.get(&name) {
                            println!("  Function '{}':", name);
                            println!("    Constants: {:?}", dedupe_constants_for_display(&chunk.constants));
                            println!("    Instructions:");
                            for (i, instruction) in chunk.instructions.iter().enumerate() {
                                println!("    {:04}: {:?}", i, instruction);
                            }
                            println!("    Labels: {:?}", chunk.labels);
                        }
                    }
                }
                println!("------------------------");
            }
            
            // Generate VM-compatible binary if requested
            if args.binary {
                // Determine output file path
                let output_path = match &args.output {
                    Some(path) => path.clone(),
                    None => {
                        // Default to source filename with .stfl extension
                        let mut default_path = file_path.with_extension("stfl").to_string_lossy().to_string();
                        println!("No output file specified, using default: {}", default_path);
                        default_path
                    }
                };
                
                // Convert to VM binary format
                println!("Generating VM-compatible binary...");
                let binary = binary_converter::convert_to_binary(&compiled_program);
                
                // Save to file
                match binary_converter::save_to_file(&binary, &output_path) {
                    Ok(_) => println!("Binary saved to {}", output_path),
                    Err(e) => eprintln!("Error saving binary: {:?}", e),
                }
            }
        }
        Err(errors) => {
            eprintln!("\n{}", errors::format_error_header(errors.len())); // Use helper for consistent header
            for error in errors {
                // Create a mutable copy to add the snippet
                let mut error_with_snippet = error.clone();
                // Generate the snippet using the actual source code
                let snippet_str = errors::extract_source_snippet(&source, &error.location, 2);
                error_with_snippet.source_snippet = Some(snippet_str);
                // Print the error using the enhanced formatter
                eprintln!("{}", error_with_snippet.format_with_colors());
            }
            process::exit(1);
        }
    }
}
