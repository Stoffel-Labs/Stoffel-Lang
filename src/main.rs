use std::fs;
use std::path::{Path, PathBuf};
use std::process;

use clap::Parser as ClapParser; // Alias to avoid name clash with our parser module

const SRC_EXT: &str = "stfl";
const BIN_EXT: &str = "stflb";

mod ast;
mod core_types;
mod bytecode;
mod codegen;
mod compiler;
mod lexer;
mod errors;
mod optimizations;
mod parser;
mod symbol_table;
mod semantic;
mod suggestions;
mod ufcs;
mod register_allocator;
mod binary_converter;
mod module_resolver;
mod multi_file_compiler;

/// Stoffel Language Compiler
#[derive(ClapParser, Debug)]
#[command(author, version, about, long_about = None)]
struct CliArgs {
    /// The source file to compile or the binary to disassemble
    #[arg(required = true)]
    filename: String,

    /// Output binary file path
    #[arg(short, long)]
    output: Option<String>,

    /// Generate VM-compatible binary
    #[arg(short = 'b', long)]
    binary: bool,

    /// Disassemble a compiled Stoffel binary (.stflb) instead of compiling source
    #[arg(long, action = clap::ArgAction::SetTrue)]
    disassemble: bool,

    /// Print intermediate representations (Tokens, AST)
    #[arg(long)]
    print_ir: bool,

    /// Set optimization level (0-3). Accepts `-O3` or `-O 3`.
    #[arg(short = 'O', long = "opt-level",
          default_value_t = 0,
          value_parser = clap::value_parser!(u8).range(0..=3),
          value_name = "N")]
    opt_level: u8,

    /// Enable optimizations (shorthand for -O2)
    #[arg(long, action = clap::ArgAction::SetTrue, conflicts_with = "opt_level")]
    optimize: bool,
}

fn dedupe_constants_for_display(constants: &[bytecode::Constant]) -> Vec<bytecode::Constant> {
    use std::collections::HashSet;
    let mut seen: HashSet<crate::core_types::Value> = HashSet::new();
    let mut out = Vec::with_capacity(constants.len());
    for c in constants.iter().cloned() {
        let v: crate::core_types::Value = crate::core_types::Value::from(c.clone());
        if seen.insert(v) {
            out.push(c);
        }
    }
    out
}

fn main() {
    let args = CliArgs::parse();

    let filename = &args.filename;

    // Small helpers for extension enforcement and output path shaping
    let has_ext = |p: &str, ext: &str| Path::new(p).extension().map(|e| e == ext).unwrap_or(false);
    let ensure_output_ext = |mut p: PathBuf, required_ext: &str| -> (PathBuf, Option<String>) {
        let mut warning: Option<String> = None;
        match p.extension().map(|e| e.to_string_lossy().to_string()) {
            Some(ext) if ext == required_ext => {}
            Some(other) => {
                p.set_extension(required_ext);
                warning = Some(format!(
                    "--output had extension '.{}'; adjusted to '.{}' to match required binary format",
                    other, required_ext
                ));
            }
            None => {
                p.set_extension(required_ext);
            }
        }
        (p, warning)
    };

    // Disassemble mode: read binary and print human-readable disassembly
    if args.disassemble {
        // Enforce .stflb input for disassembly
        if !has_ext(filename, BIN_EXT) {
            eprintln!(
                "Error: Disassembly expects a .{} file. Got '{}'\nHint: Use files like 'program.{}'",
                BIN_EXT, filename, BIN_EXT
            );
            process::exit(2);
        }
        match binary_converter::load_from_file(filename) {
            Ok(bin) => {
                let text = binary_converter::disassemble(&bin);
                println!("{}", text);
                return;
            }
            Err(e) => {
                eprintln!("Error loading binary '{}': {:?}", filename, e);
                process::exit(1);
            }
        }
    }

    // Compile mode: enforce .stfl source files
    if !has_ext(filename, SRC_EXT) {
        eprintln!(
            "Error: Source files must have .{} extension. Got '{}'\nHint: Rename to something like 'program.{}'",
            SRC_EXT, filename, SRC_EXT
        );
        process::exit(2);
    }

    let source = match fs::read_to_string(filename) {
        Ok(s) => s,
        Err(e) => {
            eprintln!("Error reading file '{}': {}", filename, e);
            process::exit(1);
        }
    };

    let file_path = Path::new(filename);
    let file_name = file_path.file_name().unwrap_or_default().to_string_lossy().to_string();

    let options = compiler::CompilerOptions {
        optimize: args.optimize || args.opt_level > 0,
        optimization_level: if args.optimize { 2 } else { args.opt_level },
        print_ir: args.print_ir,
    };

    println!("Compiling {}...", filename);

    // Use compile_file to automatically handle multi-file projects with imports
    match compiler::compile_file(file_path, &source, &options) {
        Ok(compiled_program) => {
            println!("Compilation successful!");

            if args.print_ir {
                println!("\n--- Generated Bytecode ---");
                println!("Main Chunk:");
                println!("  Constants: {:?}", dedupe_constants_for_display(&compiled_program.main_chunk.constants));
                println!("  Instructions:");
                for (i, instruction) in compiled_program.main_chunk.instructions.iter().enumerate() {
                    println!("{:04}: {:?}", i, instruction);
                }
                println!("  Labels: {:?}", compiled_program.main_chunk.labels);

                if !compiled_program.function_chunks.is_empty() {
                    println!("\nCompiled Functions:");

                    // Sort function names for deterministic output
                    let mut names: Vec<_> = compiled_program.function_chunks.keys().cloned().collect();
                    names.sort();
                    for name in names {
                        if let Some(chunk) = compiled_program.function_chunks.get(&name) {
                            println!("  Function '{}':", name);
                            println!("    Constants: {:?}", dedupe_constants_for_display(&chunk.constants));
                            println!("    Instructions:");
                            for (i, instruction) in chunk.instructions.iter().enumerate() {
                                println!("    {:04}: {:?}", i, instruction);
                            }
                            println!("    Labels: {:?}", chunk.labels);
                        }
                    }
                }
                println!("------------------------");
            }
            
            // Generate VM-compatible binary if requested
            if args.binary {
                // Determine output file path
                let output_path: String = {
                    let chosen = match &args.output {
                        Some(path) => PathBuf::from(path),
                        None => {
                            // Default to source filename with .stflb extension
                            file_path.with_extension(BIN_EXT)
                        }
                    };
                    let (fixed, warn) = ensure_output_ext(chosen, BIN_EXT);
                    if let Some(w) = warn {
                        eprintln!("Warning: {}", w);
                    } else if args.output.is_none() {
                        println!("No output file specified, using default: {}", fixed.to_string_lossy());
                    }
                    fixed.to_string_lossy().to_string()
                };
                
                // Convert to VM binary format
                println!("Generating VM-compatible binary...");
                let binary = binary_converter::convert_to_binary(&compiled_program);
                
                // Save to file
                match binary_converter::save_to_file(&binary, &output_path) {
                    Ok(_) => println!("Binary saved to {}", output_path),
                    Err(e) => eprintln!("Error saving binary: {:?}", e),
                }
            }
        }
        Err(errors) => {
            eprintln!("\n{}", errors::format_error_header(errors.len())); // Use helper for consistent header
            for error in errors {
                // Create a mutable copy to add the snippet
                let mut error_with_snippet = error.clone();
                // Generate the snippet using the actual source code
                let snippet_str = errors::extract_source_snippet(&source, &error.location, 2);
                error_with_snippet.source_snippet = Some(snippet_str);
                // Print the error using the enhanced formatter
                eprintln!("{}", error_with_snippet.format_with_colors());
            }
            process::exit(1);
        }
    }
}
