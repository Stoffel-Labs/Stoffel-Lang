use std::env;
use std::fs;
use std::process;

mod ast;
mod bytecode;
mod codegen;
mod lexer;
mod parser;
mod ufcs;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Usage: {} <filename.stoffel>", args[0]);
        process::exit(1);
    }

    let filename = &args[1];
    let source = match fs::read_to_string(filename) {
        Ok(s) => s,
        Err(e) => {
            eprintln!("Error reading file '{}': {}", filename, e);
            process::exit(1);
        }
    };

    println!("Compiling file: {}", filename);

    // 1. Lexing
    let tokens = match lexer::tokenize(&source) {
        Ok(t) => t,
        Err(e) => {
            eprintln!("{}", e);
            process::exit(1);
        }
    };
    println!("Tokens: {:?}", tokens); // Debug print

    // 2. Parsing
    let ast_root = match parser::parse(&tokens) {
        Ok(ast) => ast,
        Err(e) => {
            eprintln!("{}", e);
            process::exit(1);
        }
    };
    println!("Initial AST: {:?}", ast_root); // Debug print

    // 3. UFCS Transformation (AST Pass)
    let transformed_ast = ufcs::transform_ufcs(ast_root);
    println!("Transformed AST: {:?}", transformed_ast); // Debug print

    // 4. Code Generation
    let bytecode_chunk = match codegen::generate_bytecode(&transformed_ast) {
        Ok(chunk) => chunk,
        Err(e) => {
            eprintln!("{}", e);
            process::exit(1);
        }
    };

    println!("Generated Bytecode:");
    println!("Constants: {:?}", bytecode_chunk.constants);
    for (i, instruction) in bytecode_chunk.instructions.iter().enumerate() {
        println!("{:04}: {:?}", i, instruction);
    }

    // TODO: Output bytecode to a file or execute it
    println!("Compilation successful (boilerplate).");
}
