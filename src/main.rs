use std::fs;
use std::path::Path;
use std::process;

use clap::Parser as ClapParser; // Alias to avoid name clash with our parser module

mod ast;
mod core_types;
mod bytecode;
mod codegen;
mod compiler;
mod lexer;
mod errors;
mod parser;
mod symbol_table;
mod semantic;
mod suggestions;
mod ufcs;
mod register_allocator;
mod binary_converter;

/// Stoffel Language Compiler
#[derive(ClapParser, Debug)]
#[command(author, version, about, long_about = None)]
struct CliArgs {
    /// The source file to compile
    #[arg(required = true)]
    filename: String,

    /// Output binary file path
    #[arg(short, long)]
    output: Option<String>,

    /// Generate VM-compatible binary
    #[arg(short = 'b', long)]
    binary: bool,

    /// Print intermediate representations (Tokens, AST)
    #[arg(long)]
    print_ir: bool,

    /// Enable optimizations
    #[arg(short, long)]
    optimize: bool,

    /// Set optimization level (0-3)
    #[arg(short = 'O', long, default_value_t = 0, value_parser = clap::value_parser!(u8).range(0..=3))]
    opt_level: u8,
}

fn main() {
    let args = CliArgs::parse();

    let filename = &args.filename;
    let source = match fs::read_to_string(filename) {
        Ok(s) => s,
        Err(e) => {
            eprintln!("Error reading file '{}': {}", filename, e);
            process::exit(1);
        }
    };

    let file_path = Path::new(filename);
    let file_name = file_path.file_name().unwrap_or_default().to_string_lossy().to_string();

    let options = compiler::CompilerOptions {
        optimize: args.optimize,
        optimization_level: args.opt_level,
        print_ir: args.print_ir,
    };

    println!("Compiling {}...", filename);

    match compiler::compile(&source, &file_name, &options) {
        Ok(compiled_program) => {
            println!("Compilation successful!");

            println!("\n--- Generated Bytecode ---");
            println!("Main Chunk:");
            println!("  Constants: {:?}", compiled_program.main_chunk.constants);
            println!("  Instructions:");
            for (i, instruction) in compiled_program.main_chunk.instructions.iter().enumerate() {
                println!("{:04}: {:?}", i, instruction);
            }
            println!("  Labels: {:?}", compiled_program.main_chunk.labels);

            if !compiled_program.function_chunks.is_empty() {
                println!("\nCompiled Functions:");
                for (name, chunk) in &compiled_program.function_chunks {
                    println!("  Function '{}': {} instructions, {} constants", name, chunk.instructions.len(), chunk.constants.len());
                    // Optionally print full bytecode for each function too
                }
            }
            println!("------------------------");
            
            // Generate VM-compatible binary if requested
            if args.binary {
                // Determine output file path
                let output_path = match &args.output {
                    Some(path) => path.clone(),
                    None => {
                        // Default to source filename with .stfb extension
                        let mut default_path = file_path.with_extension("stfb").to_string_lossy().to_string();
                        println!("No output file specified, using default: {}", default_path);
                        default_path
                    }
                };
                
                // Convert to VM binary format
                println!("Generating VM-compatible binary...");
                let binary = binary_converter::convert_to_binary(&compiled_program);
                
                // Save to file
                match binary_converter::save_to_file(&binary, &output_path) {
                    Ok(_) => println!("Binary saved to {}", output_path),
                    Err(e) => eprintln!("Error saving binary: {:?}", e),
                }
            }
        }
        Err(errors) => {
            eprintln!("\n{}", errors::format_error_header(errors.len())); // Use helper for consistent header
            for error in errors {
                // Create a mutable copy to add the snippet
                let mut error_with_snippet = error.clone();
                // Generate the snippet using the actual source code
                let snippet_str = errors::extract_source_snippet(&source, &error.location, 2);
                error_with_snippet.source_snippet = Some(snippet_str);
                // Print the error using the enhanced formatter
                eprintln!("{}", error_with_snippet.format_with_colors());
            }
            process::exit(1);
        }
    }
}
