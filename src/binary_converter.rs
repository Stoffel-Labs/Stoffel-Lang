//! # Binary Converter for StoffelVM
//!
//! This module provides conversion functions between the compiler's internal
//! representation and the VM's binary format. It allows the compiler to generate
//! bytecode files that can be directly executed by the StoffelVM.
//!
//! The main functions provided are:
//! - `convert_to_binary`: Converts a `CompiledProgram` to a `CompiledBinary`
//! - `save_to_file`: Saves a `CompiledBinary` to a file

use crate::bytecode::{BytecodeChunk, CompiledProgram, Constant, Instruction, ResolvedInstruction};
use stoffel_vm_types::compiled_binary::{CompiledBinary, CompiledFunction, CompiledInstruction, BinaryResult};
use stoffel_vm_types::core_types::Value;
use std::collections::HashMap;
use std::path::Path;

/// Converts a compiler `CompiledProgram` to a VM `CompiledBinary`
///
/// This function takes a `CompiledProgram` generated by the compiler and converts it
/// to a `CompiledBinary` that can be executed by the VM. It handles the conversion
/// of constants, instructions, and function metadata.
///
/// # Arguments
///
/// * `program` - The compiled program to convert
///
/// # Returns
///
/// A `CompiledBinary` that can be executed by the VM
pub fn convert_to_binary(program: &CompiledProgram) -> CompiledBinary {
    let mut binary = CompiledBinary {
        version: stoffel_vm_types::compiled_binary::FORMAT_VERSION,
        constants: Vec::new(),
        functions: Vec::new(),
    };
    
    // Maps for tracking constants and functions
    let mut constant_map: HashMap<Value, usize> = HashMap::new();
    
    // Convert main chunk
    let main_function = convert_chunk_to_function(
        &mut binary, 
        "main", 
        &program.main_chunk, 
        &mut constant_map,
        None, // Main has no parent
    );
    binary.functions.push(main_function);
    
    // Convert function chunks
    for (name, chunk) in &program.function_chunks {
        // Determine parent function (if any)
        let parent = if name.contains("::") {
            let parts: Vec<&str> = name.rsplitn(2, "::").collect();
            if parts.len() > 1 {
                Some(parts[1].to_string())
            } else {
                None
            }
        } else {
            None
        };
        
        let function = convert_chunk_to_function(
            &mut binary, 
            name, 
            chunk, 
            &mut constant_map,
            parent,
        );
        binary.functions.push(function);
    }
    
    binary
}

/// Converts a `BytecodeChunk` to a `CompiledFunction`
///
/// This helper function converts a compiler `BytecodeChunk` to a VM `CompiledFunction`.
/// It handles the conversion of constants, instructions, and function metadata.
///
/// # Arguments
///
/// * `binary` - The binary to add constants to
/// * `name` - The name of the function
/// * `chunk` - The bytecode chunk to convert
/// * `constant_map` - A map of constants to their indices
/// * `parent` - The parent function name (if any)
///
/// # Returns
///
/// A `CompiledFunction` that can be added to the binary
fn convert_chunk_to_function(
    binary: &mut CompiledBinary,
    name: &str,
    chunk: &BytecodeChunk,
    constant_map: &mut HashMap<Value, usize>,
    parent: Option<String>,
) -> CompiledFunction {
    // Extract parameters from function name (if any)
    // Format: function_name(param1, param2, ...)
    let mut parameters = Vec::new();
    if let Some(params_start) = name.find('(') {
        if let Some(params_end) = name.find(')') {
            let params_str = &name[params_start + 1..params_end];
            if !params_str.is_empty() {
                parameters = params_str.split(',')
                    .map(|s| s.trim().to_string())
                    .collect();
            }
        }
    }
    
    // Add constants to binary
    for constant in &chunk.constants {
        add_constant_to_binary(binary, constant, constant_map);
    }
    
    // Convert instructions
    let mut instructions = Vec::new();
    for instruction in &chunk.instructions {
        let compiled_instruction = match instruction {
            Instruction::LD(reg, offset) => 
                CompiledInstruction::LD(*reg, *offset),
                
            Instruction::LDI(reg, value) => {
                let value_from_constant = Value::from(value.clone());
                let const_idx = get_or_add_constant(binary, &value_from_constant, constant_map);
                CompiledInstruction::LDI(*reg, const_idx)
            },
            
            Instruction::MOV(dest, src) => 
                CompiledInstruction::MOV(*dest, *src),
                
            Instruction::ADD(dest, src1, src2) => 
                CompiledInstruction::ADD(*dest, *src1, *src2),
                
            Instruction::SUB(dest, src1, src2) => 
                CompiledInstruction::SUB(*dest, *src1, *src2),
                
            Instruction::MUL(dest, src1, src2) => 
                CompiledInstruction::MUL(*dest, *src1, *src2),
                
            Instruction::DIV(dest, src1, src2) => 
                CompiledInstruction::DIV(*dest, *src1, *src2),
                
            Instruction::MOD(dest, src1, src2) => 
                CompiledInstruction::MOD(*dest, *src1, *src2),
                
            Instruction::AND(dest, src1, src2) => 
                CompiledInstruction::AND(*dest, *src1, *src2),
                
            Instruction::OR(dest, src1, src2) => 
                CompiledInstruction::OR(*dest, *src1, *src2),
                
            Instruction::XOR(dest, src1, src2) => 
                CompiledInstruction::XOR(*dest, *src1, *src2),
                
            Instruction::NOT(dest, src) => 
                CompiledInstruction::NOT(*dest, *src),
                
            Instruction::SHL(dest, src, amount) => 
                CompiledInstruction::SHL(*dest, *src, *amount),
                
            Instruction::SHR(dest, src, amount) => 
                CompiledInstruction::SHR(*dest, *src, *amount),
                
            Instruction::JMP(label) => {
                CompiledInstruction::JMP(label.clone())
            },
            
            Instruction::JMPEQ(label) => {
                CompiledInstruction::JMPEQ(label.clone())
            },
            
            Instruction::JMPNEQ(label) => {
                CompiledInstruction::JMPNEQ(label.clone())
            },
            
            Instruction::JMPLT(label) => {
                CompiledInstruction::JMPLT(label.clone())
            },
            
            Instruction::JMPGT(label) => {
                CompiledInstruction::JMPGT(label.clone())
            },
            
            Instruction::CALL(function_name) => {
                CompiledInstruction::CALL(function_name.clone())
            },
            
            Instruction::RET(reg) => 
                CompiledInstruction::RET(*reg),
                
            Instruction::PUSHARG(reg) => 
                CompiledInstruction::PUSHARG(*reg),
                
            Instruction::CMP(reg1, reg2) => 
                CompiledInstruction::CMP(*reg1, *reg2),
        };
        
        instructions.push(compiled_instruction);
    }
    
    // Create the compiled function
    CompiledFunction {
        name: name.to_string(),
        register_count: estimate_register_count(chunk),
        parameters,
        upvalues: Vec::new(), // We'll need to extract these from the AST or symbol table
        parent,
        labels: chunk.labels.clone(),
        instructions,
    }
}

/// Adds a constant to the binary and returns its index
///
/// This helper function adds a constant to the binary's constant pool
/// and returns its index. If the constant already exists in the pool,
/// it returns the existing index.
///
/// # Arguments
///
/// * `binary` - The binary to add the constant to
/// * `constant` - The constant to add
/// * `constant_map` - A map of constants to their indices
///
/// # Returns
///
/// The index of the constant in the binary's constant pool
fn add_constant_to_binary(
    binary: &mut CompiledBinary,
    constant: &Constant,
    constant_map: &mut HashMap<Value, usize>,
) -> usize {
    let value = Value::from(constant.clone());
    get_or_add_constant(binary, &value, constant_map)
}

/// Gets or adds a value to the binary's constant pool
///
/// This helper function gets the index of a value in the binary's constant pool,
/// or adds it if it doesn't exist.
///
/// # Arguments
///
/// * `binary` - The binary to add the value to
/// * `value` - The value to add
/// * `constant_map` - A map of values to their indices
///
/// # Returns
///
/// The index of the value in the binary's constant pool
fn get_or_add_constant(
    binary: &mut CompiledBinary,
    value: &Value,
    constant_map: &mut HashMap<Value, usize>,
) -> usize {
    if let Some(&idx) = constant_map.get(value) {
        return idx;
    }
    
    let idx = binary.constants.len();
    binary.constants.push(value.clone());
    constant_map.insert(value.clone(), idx);
    idx
}

/// Estimates the number of registers used by a function
///
/// This helper function estimates the number of registers used by a function
/// by scanning the instructions and finding the highest register index used.
///
/// # Arguments
///
/// * `chunk` - The bytecode chunk to analyze
///
/// # Returns
///
/// The estimated number of registers used by the function
fn estimate_register_count(chunk: &BytecodeChunk) -> usize {
    let mut max_reg = 0;
    
    for instruction in &chunk.instructions {
        match instruction {
            Instruction::LD(reg, _) |
            Instruction::LDI(reg, _) |
            Instruction::RET(reg) |
            Instruction::PUSHARG(reg) => {
                max_reg = max_reg.max(*reg);
            },
            Instruction::MOV(dest, src) |
            Instruction::NOT(dest, src) |
            Instruction::CMP(dest, src) => {
                max_reg = max_reg.max(*dest).max(*src);
            },
            Instruction::ADD(dest, src1, src2) |
            Instruction::SUB(dest, src1, src2) |
            Instruction::MUL(dest, src1, src2) |
            Instruction::DIV(dest, src1, src2) |
            Instruction::MOD(dest, src1, src2) |
            Instruction::AND(dest, src1, src2) |
            Instruction::OR(dest, src1, src2) |
            Instruction::XOR(dest, src1, src2) |
            Instruction::SHL(dest, src1, src2) |
            Instruction::SHR(dest, src1, src2) => {
                max_reg = max_reg.max(*dest).max(*src1).max(*src2);
            },
            _ => {},
        }
    }
    
    // Add 1 because registers are 0-indexed
    max_reg + 1
}

/// Saves a `CompiledBinary` to a file
///
/// This function saves a `CompiledBinary` to a file that can be loaded and
/// executed by the VM.
///
/// # Arguments
///
/// * `binary` - The binary to save
/// * `path` - The path to save the binary to
///
/// # Returns
///
/// A `Result` indicating success or failure
pub fn save_to_file<P: AsRef<Path>>(binary: &CompiledBinary, path: P) -> BinaryResult<()> {
    stoffel_vm_types::compiled_binary::utils::save_to_file(binary, path)
}